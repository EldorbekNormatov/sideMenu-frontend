<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>iOS-Style A4 Scanner ‚Äî Improved</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    .video-box { aspect-ratio: 3/4; object-fit: cover; border-radius: 12px; }
    .overlay-canvas { position: absolute; inset: 0; pointer-events: none; }
    .focus-ring { position: absolute; width: 80px; height: 80px; border: 4px solid #fbbf24; border-radius: 9999px; display: none; pointer-events: none; transform: translate(-50%,-50%); }
  </style>
</head>

<body class="bg-slate-900 text-white min-h-screen flex justify-center py-8">
  <div class="w-full max-w-md px-4">
    <h1 class="text-xl font-semibold mb-3">üìÑ iOS-Style A4 Scanner ‚Äî Optimized</h1>

    <div class="flex gap-3 mb-3">
      <button id="startBtn" class="flex-1 bg-slate-700 py-3 rounded-full">üì∏ Open Camera</button>
      <button id="toggleAuto" class="px-3 bg-slate-600 rounded-full">‚öôÔ∏è Auto: ON</button>
    </div>

    <p id="status" class="text-xs text-yellow-300 min-h-[20px] mb-2"></p>

    <div id="camera-box" class="relative hidden">
      <div id="infoOverlay" class="absolute left-1/2 -translate-x-1/2 bottom-3 bg-black/60 px-3 py-1 rounded-full text-xs z-20"></div>

      <video id="video" autoplay playsinline class="w-full bg-black video-box"></video>
      <canvas id="overlay" class="overlay-canvas z-10"></canvas>

      <div class="mt-3 flex gap-2">
        <button id="captureBtn" class="flex-1 bg-emerald-500 py-2 rounded-full">üì∑ Capture</button>
        <button id="saveBtn" class="flex-1 bg-blue-600 py-2 rounded-full hidden">üíæ Upload</button>
      </div>
    </div>

    <h3 class="mt-6 font-bold text-sm">Captured</h3>
    <div id="preview" class="space-y-2 mt-2"></div>
  </div>

<script>
/* =========================
   CONFIG / STATE
   ========================= */
const API_BASE = "https://panel.nvmailer.uz";
const CHECK_ENDPOINT = API_BASE + "/photo-check";
const SAVE_ENDPOINT = API_BASE + "/photo-save";

let stream = null;
let videoTrack = null;
let cvReady = false;
let rawQuad = null, lastQuad = null;
let quadHistory = [];
const QUAD_HISTORY_LEN = 6;
let stableFrames = 0;
let autoCapture = true;
let lastCaptureAt = 0;
let images = [];

/* DOM */
const startBtn = document.getElementById("startBtn");
const toggleAuto = document.getElementById("toggleAuto");
const statusEl = document.getElementById("status");
const cameraBox = document.getElementById("camera-box");
const videoEl = document.getElementById("video");
const overlay = document.getElementById("overlay");
const overlayCtx = overlay.getContext("2d");
const infoOverlay = document.getElementById("infoOverlay");
const captureBtn = document.getElementById("captureBtn");
const saveBtn = document.getElementById("saveBtn");
const previewEl = document.getElementById("preview");

function setStatus(t,c="yellow"){ statusEl.textContent=t; statusEl.className = c==="green"?"text-green-400 text-xs":c==="red"?"text-red-400 text-xs":"text-yellow-300 text-xs"; }
function setInfo(t=""){ infoOverlay.textContent = t; }

function orderQuad(pts){
  const sum = pts.map(p=>p.x+p.y);
  const diff = pts.map(p=>p.y-p.x);
  const tl = pts[sum.indexOf(Math.min(...sum))];
  const br = pts[sum.indexOf(Math.max(...sum))];
  const tr = pts[diff.indexOf(Math.min(...diff))];
  const bl = pts[diff.indexOf(Math.max(...diff))];
  return [tl,tr,br,bl];
}
function isValidQuad(q){ return q && q.length===4 && q.every(p=>p.x>2 && p.y>2); }

function smoothQuad(newQ){
  if(!isValidQuad(newQ)) return null;
  quadHistory.push(newQ);
  if(quadHistory.length > QUAD_HISTORY_LEN) quadHistory.shift();
  const n = quadHistory.length;
  const avg = [{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}];
  quadHistory.forEach(q=>{
    for(let i=0;i<4;i++){ avg[i].x += q[i].x; avg[i].y += q[i].y; }
  });
  for(let i=0;i<4;i++){ avg[i].x /= n; avg[i].y /= n; }
  return avg;
}
function quadMotion(a,b){
  if(!isValidQuad(a) || !isValidQuad(b)) return Infinity;
  let s=0; for(let i=0;i<4;i++) s+= Math.hypot(a[i].x-b[i].x, a[i].y-b[i].y);
  return s/4;
}

/* luminance */
function meanLuminanceFromCanvas(c){
  try {
    const ctx = c.getContext('2d');
    const d = ctx.getImageData(0,0,c.width,c.height).data;
    let s=0,n=0;
    for(let i=0;i<d.length;i+=4){ s += 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; n++; }
    return s/n;
  } catch(e){ return 120; }
}

/* beep */
function beep(){ try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.connect(g); g.connect(ctx.destination); o.start(); g.gain.setValueAtTime(0.05,ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18); o.stop(ctx.currentTime + 0.19);}catch(e){} }

/* Wait for OpenCV */
(function waitForCV(){
  const timer = setInterval(()=>{
    if(window.cv && cv.Mat){
      cv.onRuntimeInitialized = ()=>{ cvReady = true; setStatus("OpenCV ready","green"); };
      clearInterval(timer);
    }
  },120);
})();

/* =========================
   DETECTION (optimized)
   - process smaller frame (scaleDown) for speed
   - map coordinates back
   - morphological cleaning + contour approx
   ========================= */
function startDetectionLoop(){
  // processing canvas (smaller)
  const procMax = 800; // tune for perf: 600..1000
  const detectCanvas = document.createElement('canvas');
  const dctx = detectCanvas.getContext('2d');

  let prevSmooth = null;

  function step(){
    if(!stream) return;
    if(!cvReady || !videoEl.videoWidth){ requestAnimationFrame(step); return; }

    const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
    overlay.width = vw; overlay.height = vh;

    // compute scale to downsample (keep aspect)
    const scale = Math.min(1, procMax / Math.max(vw, vh));
    const pw = Math.max(320, Math.floor(vw * scale));
    const ph = Math.max(320, Math.floor(vh * scale));
    detectCanvas.width = pw; detectCanvas.height = ph;

    // draw scaled frame
    dctx.drawImage(videoEl, 0, 0, pw, ph);

    // opencv on detectCanvas
    let src = cv.imread(detectCanvas);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();
    let hier = new cv.Mat();
    let contours = new cv.MatVector();

    // convert & preprocess
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    // adaptive threshold works well in uneven lighting
    cv.adaptiveThreshold(gray, edges, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
    // morphology close to fill gaps
    let M = cv.Mat.ones(5,5,cv.CV_8U);
    cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, M);

    // find contours
    cv.findContours(edges, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // choose best quad (largest area after approx)
    let bestArea = 0, bestQuad = null;
    for(let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, peri * 0.02, true);
      if(approx.rows === 4){
        const area = cv.contourArea(approx);
        if(area > bestArea){
          bestArea = area;
          if(bestQuad) bestQuad.delete();
          bestQuad = approx;
        } else approx.delete();
      } else approx.delete();
      cnt.delete();
    }

    // clear overlay
    overlayCtx.clearRect(0,0,overlay.width,overlay.height);

    if(bestQuad && bestArea > (pw*ph)*0.08){
      // get scaled points and map to original video coords
      const ptsScaled = [];
      for(let i=0;i<4;i++) ptsScaled.push({ x: bestQuad.intAt(i,0), y: bestQuad.intAt(i,1) });

      // map back: x_orig = x_scaled * (vw/pw)
      const sx = vw / pw, sy = vh / ph;
      const ptsOrig = ptsScaled.map(p => ({ x: p.x * sx, y: p.y * sy }));

      rawQuad = orderQuad(ptsOrig);
      const sm = smoothQuad(rawQuad);
      lastQuad = sm;

      // draw dark mask + yellow highlight
      overlayCtx.fillStyle = "rgba(0,0,0,0.55)";
      overlayCtx.fillRect(0,0,overlay.width,overlay.height);

      // cut-out path
      overlayCtx.save();
      overlayCtx.beginPath();
      overlayCtx.moveTo(sm[0].x, sm[0].y);
      overlayCtx.lineTo(sm[1].x, sm[1].y);
      overlayCtx.lineTo(sm[2].x, sm[2].y);
      overlayCtx.lineTo(sm[3].x, sm[3].y);
      overlayCtx.closePath();
      overlayCtx.globalCompositeOperation = "destination-out";
      overlayCtx.fill();
      overlayCtx.restore();

      // yellow fill
      overlayCtx.fillStyle = "rgba(255,220,0,0.34)";
      overlayCtx.beginPath();
      overlayCtx.moveTo(sm[0].x, sm[0].y);
      overlayCtx.lineTo(sm[1].x, sm[1].y);
      overlayCtx.lineTo(sm[2].x, sm[2].y);
      overlayCtx.lineTo(sm[3].x, sm[3].y);
      overlayCtx.closePath();
      overlayCtx.fill();

      // border glow
      overlayCtx.lineWidth = Math.max(3, Math.round(Math.min(vw,vh) * 0.003));
      overlayCtx.strokeStyle = "rgba(255,200,0,0.28)";
      overlayCtx.stroke();
      overlayCtx.lineWidth = Math.max(2, Math.round(Math.min(vw,vh) * 0.0018));
      overlayCtx.strokeStyle = "rgb(255,200,0)";
      overlayCtx.stroke();

      setInfo("üìÑ Hujjat topildi ‚Äî joyini barqarorlang");

      // auto-capture conditions
      const areaRatio = bestArea / (pw*ph); // in scaled coords
      const br = meanLuminanceFromCanvas(detectCanvas);
      const motion = prevSmooth ? quadMotion(sm, prevSmooth) : 9999;

      const goodArea = areaRatio > 0.28;
      const lowMotion = motion < Math.max(vw,vh) * 0.007;
      const goodLight = br > 45;

      if(goodArea && lowMotion && goodLight && autoCapture) stableFrames++; else stableFrames = Math.max(0, stableFrames - 1);

      if(stableFrames >= 6 && (Date.now() - lastCaptureAt) > 1200){
        stableFrames = 0;
        lastCaptureAt = Date.now();
        beep();
        triggerCapture(true);
      }

      prevSmooth = sm;

    } else {
      // no good quad
      rawQuad = null; lastQuad = null;
      quadHistory = []; stableFrames = 0;
      setInfo("Hujjatni butun kadrga joylashtiring");
    }

    // cleanup
    src.delete(); gray.delete(); blur.delete(); edges.delete(); hier.delete(); contours.delete();
    if(bestQuad) bestQuad.delete();
    if(typeof M !== 'undefined') M.delete();

    requestAnimationFrame(step);
  }

  step();
}

/* =========================
   CAMERA OPEN
   ========================= */
startBtn.addEventListener("click", async ()=>{
  try{
    setStatus("Kamera ochilyapti...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
      audio: false
    });
    videoTrack = stream.getVideoTracks()[0];
    videoEl.srcObject = stream;
    cameraBox.classList.remove("hidden");
    setStatus("Kamera tayyor", "green");
    startDetectionLoop();
  } catch(e){
    console.error(e);
    setStatus("Kamera ochilmadi", "red");
  }
});

/* =========================
   CAPTURE + ENHANCE (same as earlier)
   ========================= */
async function triggerCapture(autoFlag=false){
  if(!videoEl.videoWidth) return;
  setStatus(autoFlag ? "Auto-capturing..." : "Capturing...");
  const base = document.createElement('canvas');
  base.width = videoEl.videoWidth; base.height = videoEl.videoHeight;
  base.getContext('2d').drawImage(videoEl, 0, 0, base.width, base.height);

  let finalCanvas = base;
  if(cvReady && lastQuad && isValidQuad(lastQuad)){
    try{
      const pts = lastQuad;
      const w1 = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
      const w2 = Math.hypot(pts[2].x-pts[3].x, pts[2].y-pts[3].y);
      const h1 = Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
      const h2 = Math.hypot(pts[2].x-pts[1].x, pts[2].y-pts[1].y);
      const dstW = Math.max(Math.floor(w1), Math.floor(w2));
      const dstH = Math.max(Math.floor(h1), Math.floor(h2));

      const src = cv.imread(base);
      const dst = new cv.Mat();
      const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[pts[0].x,pts[0].y, pts[1].x,pts[1].y, pts[2].x,pts[2].y, pts[3].x,pts[3].y]);
      const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, dstW,0, dstW,dstH, 0,dstH]);
      const M = cv.getPerspectiveTransform(srcTri,dstTri);
      cv.warpPerspective(src,dst,M,new cv.Size(dstW,dstH));

      // image enhance attempt (safe fallbacks)
      try{
        let lab = new cv.Mat();
        cv.cvtColor(dst, lab, cv.COLOR_RGBA2Lab);
        let planes = new cv.MatVector(); cv.split(lab, planes);
        let L = planes.get(0);
        let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
        let Lc = new cv.Mat();
        clahe.apply(L, Lc);
        planes.set(0, Lc);
        cv.merge(planes, lab);
        let enhanced = new cv.Mat();
        cv.cvtColor(lab, enhanced, cv.COLOR_Lab2RGBA);
        let smooth = new cv.Mat();
        cv.bilateralFilter(enhanced, smooth, 9, 75, 75);
        let sharpen = new cv.Mat();
        cv.addWeighted(enhanced, 1.5, smooth, -0.5, 0, sharpen);
        finalCanvas = document.createElement('canvas'); finalCanvas.width = sharpen.cols; finalCanvas.height = sharpen.rows;
        cv.imshow(finalCanvas, sharpen);
        // cleanup
        L.delete(); Lc.delete(); planes.delete(); lab.delete();
        clahe.delete(); enhanced.delete(); smooth.delete(); sharpen.delete();
      } catch(e){
        finalCanvas = document.createElement('canvas'); finalCanvas.width = dst.cols; finalCanvas.height = dst.rows;
        cv.imshow(finalCanvas, dst);
      }

      src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
    } catch(e){
      console.error("Warp error", e);
      finalCanvas = base;
    }
  }

  const blob = await new Promise(res => finalCanvas.toBlob(res, "image/jpeg", 0.92));
  if(!blob){ setStatus("Capture failed", "red"); return; }

  images.push({ blob, url: URL.createObjectURL(blob) });
  renderPreview();
  saveBtn.classList.remove("hidden");
  setStatus("Saved", "green");
}

/* bind manual capture */
captureBtn.addEventListener("click", ()=> triggerCapture(false));

/* =========================
   PREVIEW & UPLOAD
   ========================= */
function renderPreview(){
  previewEl.innerHTML = "";
  images.forEach((it, idx)=>{
    const card = document.createElement('div');
    card.className = "bg-slate-800 p-2 rounded-xl border border-slate-700 flex items-center gap-3";
    const img = document.createElement('img'); img.src = it.url; img.className="w-24 h-24 object-cover rounded";
    card.appendChild(img);
    const dl = document.createElement('a'); dl.href=it.url; dl.download=`scan_${idx+1}.jpg`; dl.className="ml-auto px-2 py-1 bg-blue-600 rounded text-xs"; dl.textContent="‚¨áÔ∏è";
    card.appendChild(dl);
    const del = document.createElement('button'); del.className="ml-2 px-2 py-1 bg-red-600 rounded text-xs"; del.textContent="üóë";
    del.onclick = ()=> { images.splice(idx,1); renderPreview(); if(images.length===0) saveBtn.classList.add("hidden"); };
    card.appendChild(del);
    previewEl.appendChild(card);
  });
}

/* save all to server */
saveBtn.addEventListener("click", async ()=>{
  if(images.length===0) return;
  setStatus("Uploading...");
  const form = new FormData();
  images.forEach((it,i)=> form.append("photos", it.blob, `photo_${i}.jpg`));
  form.append("uid", localStorage.getItem("driver_uid") || "");
  try{
    const res = await fetch(SAVE_ENDPOINT, { method: "POST", body: form });
    const data = await res.json();
    if(data.ok){ images = []; renderPreview(); saveBtn.classList.add("hidden"); setStatus("All uploaded", "green"); }
    else setStatus(data.msg || "Upload failed", "red");
  } catch(e){ console.error(e); setStatus("Upload error", "red"); }
});

/* toggle auto */
toggleAuto.addEventListener("click", ()=> { autoCapture = !autoCapture; toggleAuto.textContent = `‚öôÔ∏è Auto: ${autoCapture ? "ON":"OFF"}`; });

/* cleanup */
window.addEventListener("beforeunload", ()=> { if(stream) stream.getTracks().forEach(t=>t.stop()); });

</script>
</body>
</html>
