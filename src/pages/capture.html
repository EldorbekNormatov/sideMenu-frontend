<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>iOS-Style A4 Scanner ‚Äî Improved</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    .video-box { aspect-ratio: 3/4; object-fit: cover; border-radius: 12px; }
    .overlay-canvas { position: absolute; inset: 0; pointer-events: none; }
    .focus-ring { position: absolute; width: 80px; height: 80px; border: 4px solid #fbbf24; border-radius: 9999px; display: none; pointer-events: none; transform: translate(-50%,-50%); }
  </style>
</head>

<body class="bg-slate-900 text-white min-h-screen flex justify-center py-8">
  <div class="w-full max-w-md px-4">
    <h1 class="text-xl font-semibold mb-3">üìÑ iOS-Style A4 Scanner ‚Äî Optimized</h1>

    <div class="flex gap-3 mb-3">
      <button id="startBtn" class="flex-1 bg-slate-700 py-3 rounded-full">üì∏ Open Camera</button>
      <button id="toggleAuto" class="px-3 bg-slate-600 rounded-full">‚öôÔ∏è Auto: ON</button>
    </div>

    <p id="status" class="text-xs text-yellow-300 min-h-[20px] mb-2"></p>

    <div id="camera-box" class="relative hidden">
      <div id="infoOverlay" class="absolute left-1/2 -translate-x-1/2 bottom-3 bg-black/60 px-3 py-1 rounded-full text-xs z-20"></div>

      <video id="video" autoplay playsinline class="w-full bg-black video-box"></video>
      <canvas id="overlay" class="overlay-canvas z-10"></canvas>

      <div class="mt-3 flex gap-2">
        <button id="captureBtn" class="flex-1 bg-emerald-500 py-2 rounded-full">üì∑ Capture</button>
        <button id="saveBtn" class="flex-1 bg-blue-600 py-2 rounded-full hidden">üíæ Upload</button>
      </div>
    </div>

    <h3 class="mt-6 font-bold text-sm">Captured</h3>
    <div id="preview" class="space-y-2 mt-2"></div>
  </div>

<script>
/* =========================
   CONFIG / STATE
   ========================= */
const API_BASE = "https://panel.nvmailer.uz";
const CHECK_ENDPOINT = API_BASE + "/photo-check";
const SAVE_ENDPOINT = API_BASE + "/photo-save";

let stream = null;
let videoTrack = null;
let cvReady = false;
let rawQuad = null, lastQuad = null;
let quadHistory = [];
const QUAD_HISTORY_LEN = 6;
let stableFrames = 0;
let autoCapture = true;
let lastCaptureAt = 0;
let images = [];

/* DOM */
const startBtn = document.getElementById("startBtn");
const toggleAuto = document.getElementById("toggleAuto");
const statusEl = document.getElementById("status");
const cameraBox = document.getElementById("camera-box");
const videoEl = document.getElementById("video");
const overlay = document.getElementById("overlay");
const overlayCtx = overlay.getContext("2d");
const infoOverlay = document.getElementById("infoOverlay");
const captureBtn = document.getElementById("captureBtn");
const saveBtn = document.getElementById("saveBtn");
const previewEl = document.getElementById("preview");

function setStatus(t,c="yellow"){ statusEl.textContent=t; statusEl.className = c==="green"?"text-green-400 text-xs":c==="red"?"text-red-400 text-xs":"text-yellow-300 text-xs"; }
function setInfo(t=""){ infoOverlay.textContent = t; }

function orderQuad(pts){
  const sum = pts.map(p=>p.x+p.y);
  const diff = pts.map(p=>p.y-p.x);
  const tl = pts[sum.indexOf(Math.min(...sum))];
  const br = pts[sum.indexOf(Math.max(...sum))];
  const tr = pts[diff.indexOf(Math.min(...diff))];
  const bl = pts[diff.indexOf(Math.max(...diff))];
  return [tl,tr,br,bl];
}
function isValidQuad(q){ return q && q.length===4 && q.every(p=>p.x>2 && p.y>2); }

function smoothQuad(newQ){
  if(!isValidQuad(newQ)) return null;
  quadHistory.push(newQ);
  if(quadHistory.length > QUAD_HISTORY_LEN) quadHistory.shift();
  const n = quadHistory.length;
  const avg = [{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}];
  quadHistory.forEach(q=>{
    for(let i=0;i<4;i++){ avg[i].x += q[i].x; avg[i].y += q[i].y; }
  });
  for(let i=0;i<4;i++){ avg[i].x /= n; avg[i].y /= n; }
  return avg;
}
function quadMotion(a,b){
  if(!isValidQuad(a) || !isValidQuad(b)) return Infinity;
  let s=0; for(let i=0;i<4;i++) s+= Math.hypot(a[i].x-b[i].x, a[i].y-b[i].y);
  return s/4;
}

/* luminance */
function meanLuminanceFromCanvas(c){
  try {
    const ctx = c.getContext('2d');
    const d = ctx.getImageData(0,0,c.width,c.height).data;
    let s=0,n=0;
    for(let i=0;i<d.length;i+=4){ s += 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; n++; }
    return s/n;
  } catch(e){ return 120; }
}

/* beep */
function beep(){ try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.connect(g); g.connect(ctx.destination); o.start(); g.gain.setValueAtTime(0.05,ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18); o.stop(ctx.currentTime + 0.19);}catch(e){} }

/* Wait for OpenCV */
(function waitForCV(){
  const timer = setInterval(()=>{
    if(window.cv && cv.Mat){
      cv.onRuntimeInitialized = ()=>{ cvReady = true; setStatus("OpenCV ready","green"); };
      clearInterval(timer);
    }
  },120);
})();

/* =========================
   DETECTION (optimized)
   - process smaller frame (scaleDown) for speed
   - map coordinates back
   - morphological cleaning + contour approx
   ========================= */
function startDetectionLoop(){
  const detectCanvas = document.createElement("canvas");
  const dctx = detectCanvas.getContext("2d");

  const minAreaRatio = 0.05;     // oldingi 0.12 juda yuqori edi
  const targetA4 = 1.0;          // aspect ratio penalty
  const A4ratio = 1.414;         // A4 proportion

  function step(){
    if(!stream){ requestAnimationFrame(step); return; }
    if(!cvReady || !videoEl.videoWidth){
      requestAnimationFrame(step); return;
    }

    const vw = videoEl.videoWidth;
    const vh = videoEl.videoHeight;
    const scale = 600 / Math.max(vw, vh);

    const pw = Math.floor(vw * scale);
    const ph = Math.floor(vh * scale);

    detectCanvas.width = pw;
    detectCanvas.height = ph;
    overlay.width = vw;
    overlay.height = vh;

    // draw scaled video
    dctx.drawImage(videoEl, 0, 0, pw, ph);

    /* --- OPENCV START --- */
    let src = cv.imread(detectCanvas);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();
    let dil = new cv.Mat();
    let close = new cv.Mat();
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();

    // preprocess
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

    // Canny is best for iPhone-like scanner
    cv.Canny(blur, edges, 60, 160);

    // strengthen edges
    const kernel = cv.Mat.ones(5,5,cv.CV_8U);
    cv.dilate(edges, dil, kernel);
    cv.morphologyEx(dil, close, cv.MORPH_CLOSE, kernel);

    cv.findContours(close, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let bestQuad = null;
    let bestScore = 0;

    for (let i = 0; i < contours.size(); i++){
      let cnt = contours.get(i);
      let peri = cv.arcLength(cnt, true);
      let approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, peri * 0.018, true);

      if(approx.rows === 4){
        let area = cv.contourArea(approx);
        let areaRatio = area / (pw * ph);
        if(areaRatio < minAreaRatio){
          approx.delete(); continue;
        }

        // Calculate aspect ratio score
        let pts = [];
        for(let j=0;j<4;j++)
          pts.push({x: approx.intAt(j,0), y: approx.intAt(j,1)});

        let o = orderQuad(pts);
        let w1 = Math.hypot(o[1].x-o[0].x, o[1].y-o[0].y);
        let h1 = Math.hypot(o[3].x-o[0].x, o[3].y-o[0].y);
        let ratio = Math.max(w1,h1) / Math.min(w1,h1);
        let ratioScore = 1 - Math.abs(ratio - A4ratio) * 0.4; // closer to A4 ratio, better

        let final = areaRatio + ratioScore;
        if(final > bestScore){
          bestScore = final;
          if(bestQuad) bestQuad.delete();
          bestQuad = approx;
        } else approx.delete();
      } else approx.delete();

      cnt.delete();
    }

    overlayCtx.clearRect(0,0,vw,vh);

    if(bestQuad){
      // map coords back to full-resolution video
      const sx = vw / pw;
      const sy = vh / ph;
      let pts = [];
      for(let i=0;i<4;i++)
        pts.push({
          x: bestQuad.intAt(i,0) * sx,
          y: bestQuad.intAt(i,1) * sy
        });

      pts = orderQuad(pts);
      lastQuad = pts;

      /* --- SARIQ HIGHLIGHT --- */
      overlayCtx.fillStyle = "rgba(0,0,0,0.55)";
      overlayCtx.fillRect(0,0,vw,vh);

      overlayCtx.save();
      overlayCtx.beginPath();
      overlayCtx.moveTo(pts[0].x, pts[0].y);
      overlayCtx.lineTo(pts[1].x, pts[1].y);
      overlayCtx.lineTo(pts[2].x, pts[2].y);
      overlayCtx.lineTo(pts[3].x, pts[3].y);
      overlayCtx.closePath();

      overlayCtx.globalCompositeOperation = "destination-out";
      overlayCtx.fill();
      overlayCtx.restore();

      overlayCtx.fillStyle = "rgba(255,220,0,0.35)";
      overlayCtx.beginPath();
      overlayCtx.moveTo(pts[0].x, pts[0].y);
      overlayCtx.lineTo(pts[1].x, pts[1].y);
      overlayCtx.lineTo(pts[2].x, pts[2].y);
      overlayCtx.lineTo(pts[3].x, pts[3].y);
      overlayCtx.closePath();
      overlayCtx.fill();

      overlayCtx.lineWidth = 4;
      overlayCtx.strokeStyle = "rgb(255,200,0)";
      overlayCtx.stroke();

      setInfo("üìÑ Hujjat topildi");

    } else {
      lastQuad = null;
      setInfo("Hujjatni kadrga joylashtiring");
    }

    // cleanup
    src.delete(); gray.delete(); blur.delete();
    edges.delete(); dil.delete(); close.delete();
    contours.delete(); hierarchy.delete();
    if(bestQuad) bestQuad.delete();

    requestAnimationFrame(step);
  }

  step();
}

/* =========================
   CAMERA OPEN
   ========================= */
startBtn.addEventListener("click", async ()=>{
  try{
    setStatus("Kamera ochilyapti...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
      audio: false
    });
    videoTrack = stream.getVideoTracks()[0];
    videoEl.srcObject = stream;
    cameraBox.classList.remove("hidden");
    setStatus("Kamera tayyor", "green");
    startDetectionLoop();
  } catch(e){
    console.error(e);
    setStatus("Kamera ochilmadi", "red");
  }
});

/* =========================
   CAPTURE + ENHANCE (same as earlier)
   ========================= */
async function triggerCapture(autoFlag=false){
  if(!videoEl.videoWidth) return;
  setStatus(autoFlag ? "Auto-capturing..." : "Capturing...");
  const base = document.createElement('canvas');
  base.width = videoEl.videoWidth; base.height = videoEl.videoHeight;
  base.getContext('2d').drawImage(videoEl, 0, 0, base.width, base.height);

  let finalCanvas = base;
  if(cvReady && lastQuad && isValidQuad(lastQuad)){
    try{
      const pts = lastQuad;
      const w1 = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
      const w2 = Math.hypot(pts[2].x-pts[3].x, pts[2].y-pts[3].y);
      const h1 = Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
      const h2 = Math.hypot(pts[2].x-pts[1].x, pts[2].y-pts[1].y);
      const dstW = Math.max(Math.floor(w1), Math.floor(w2));
      const dstH = Math.max(Math.floor(h1), Math.floor(h2));

      const src = cv.imread(base);
      const dst = new cv.Mat();
      const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[pts[0].x,pts[0].y, pts[1].x,pts[1].y, pts[2].x,pts[2].y, pts[3].x,pts[3].y]);
      const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, dstW,0, dstW,dstH, 0,dstH]);
      const M = cv.getPerspectiveTransform(srcTri,dstTri);
      cv.warpPerspective(src,dst,M,new cv.Size(dstW,dstH));

      // image enhance attempt (safe fallbacks)
      try{
        let lab = new cv.Mat();
        cv.cvtColor(dst, lab, cv.COLOR_RGBA2Lab);
        let planes = new cv.MatVector(); cv.split(lab, planes);
        let L = planes.get(0);
        let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
        let Lc = new cv.Mat();
        clahe.apply(L, Lc);
        planes.set(0, Lc);
        cv.merge(planes, lab);
        let enhanced = new cv.Mat();
        cv.cvtColor(lab, enhanced, cv.COLOR_Lab2RGBA);
        let smooth = new cv.Mat();
        cv.bilateralFilter(enhanced, smooth, 9, 75, 75);
        let sharpen = new cv.Mat();
        cv.addWeighted(enhanced, 1.5, smooth, -0.5, 0, sharpen);
        finalCanvas = document.createElement('canvas'); finalCanvas.width = sharpen.cols; finalCanvas.height = sharpen.rows;
        cv.imshow(finalCanvas, sharpen);
        // cleanup
        L.delete(); Lc.delete(); planes.delete(); lab.delete();
        clahe.delete(); enhanced.delete(); smooth.delete(); sharpen.delete();
      } catch(e){
        finalCanvas = document.createElement('canvas'); finalCanvas.width = dst.cols; finalCanvas.height = dst.rows;
        cv.imshow(finalCanvas, dst);
      }

      src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
    } catch(e){
      console.error("Warp error", e);
      finalCanvas = base;
    }
  }

  const blob = await new Promise(res => finalCanvas.toBlob(res, "image/jpeg", 0.92));
  if(!blob){ setStatus("Capture failed", "red"); return; }

  images.push({ blob, url: URL.createObjectURL(blob) });
  renderPreview();
  saveBtn.classList.remove("hidden");
  setStatus("Saved", "green");
}

/* bind manual capture */
captureBtn.addEventListener("click", ()=> triggerCapture(false));

/* =========================
   PREVIEW & UPLOAD
   ========================= */
function renderPreview(){
  previewEl.innerHTML = "";
  images.forEach((it, idx)=>{
    const card = document.createElement('div');
    card.className = "bg-slate-800 p-2 rounded-xl border border-slate-700 flex items-center gap-3";
    const img = document.createElement('img'); img.src = it.url; img.className="w-24 h-24 object-cover rounded";
    card.appendChild(img);
    const dl = document.createElement('a'); dl.href=it.url; dl.download=`scan_${idx+1}.jpg`; dl.className="ml-auto px-2 py-1 bg-blue-600 rounded text-xs"; dl.textContent="‚¨áÔ∏è";
    card.appendChild(dl);
    const del = document.createElement('button'); del.className="ml-2 px-2 py-1 bg-red-600 rounded text-xs"; del.textContent="üóë";
    del.onclick = ()=> { images.splice(idx,1); renderPreview(); if(images.length===0) saveBtn.classList.add("hidden"); };
    card.appendChild(del);
    previewEl.appendChild(card);
  });
}

/* save all to server */
saveBtn.addEventListener("click", async ()=>{
  if(images.length===0) return;
  setStatus("Uploading...");
  const form = new FormData();
  images.forEach((it,i)=> form.append("photos", it.blob, `photo_${i}.jpg`));
  form.append("uid", localStorage.getItem("driver_uid") || "");
  try{
    const res = await fetch(SAVE_ENDPOINT, { method: "POST", body: form });
    const data = await res.json();
    if(data.ok){ images = []; renderPreview(); saveBtn.classList.add("hidden"); setStatus("All uploaded", "green"); }
    else setStatus(data.msg || "Upload failed", "red");
  } catch(e){ console.error(e); setStatus("Upload error", "red"); }
});

/* toggle auto */
toggleAuto.addEventListener("click", ()=> { autoCapture = !autoCapture; toggleAuto.textContent = `‚öôÔ∏è Auto: ${autoCapture ? "ON":"OFF"}`; });

/* cleanup */
window.addEventListener("beforeunload", ()=> { if(stream) stream.getTracks().forEach(t=>t.stop()); });

</script>
</body>
</html>
