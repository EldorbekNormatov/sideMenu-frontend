<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>iOS-Style A4 Scanner ‚Äî Full Clone (Wood-safe)</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- OpenCV.js (WASM) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    body { -webkit-font-smoothing:antialiased; }
    .video-box { aspect-ratio: 3/4; object-fit: cover; border-radius: 12px; }
    .overlay-canvas { position: absolute; inset: 0; pointer-events: none; }
    .focus-ring { position: absolute; width: 80px; height: 80px; border: 4px solid #fbbf24; border-radius: 9999px; display: none; pointer-events: none; transform: translate(-50%,-50%); }
  </style>
</head>
<body class="bg-slate-900 text-white min-h-screen flex justify-center py-8">

  <div class="w-full max-w-md px-4">
    <h1 class="text-xl font-semibold mb-3">üìÑ iOS-Style A4 Scanner ‚Äî Wood-safe Full</h1>

    <div class="flex gap-3 mb-3">
      <button id="startBtn" class="flex-1 bg-slate-700 py-3 rounded-full">üì∏ Open Camera</button>
      <button id="toggleAuto" class="px-3 bg-slate-600 rounded-full">‚öôÔ∏è Auto: ON</button>
    </div>

    <p id="status" class="text-xs text-yellow-300 min-h-[20px] mb-2"></p>

    <div id="camera-box" class="relative hidden">
      <div id="infoOverlay" class="absolute left-1/2 -translate-x-1/2 bottom-3 bg-black/60 px-3 py-1 rounded-full text-xs z-20"></div>

      <video id="video" autoplay playsinline class="w-full bg-black video-box"></video>
      <canvas id="overlay" class="overlay-canvas z-10"></canvas>

      <div class="mt-3 flex gap-2">
        <button id="captureBtn" class="flex-1 bg-emerald-500 py-2 rounded-full">üì∑ Capture</button>
        <button id="saveBtn" class="flex-1 bg-blue-600 py-2 rounded-full hidden">üíæ Upload</button>
      </div>
    </div>

    <h3 class="mt-6 font-bold text-sm">Captured</h3>
    <div id="preview" class="space-y-2 mt-2"></div>
  </div>

<script>
/* =========================
   Full iOS-style scanner
   - Improved for wood/textured backgrounds
   - Auto-capture, smoothing, CLAHE enhance, upload
   ========================= */

/* CONFIG */
const API_BASE = "https://panel.nvmailer.uz"; // change if needed
const SAVE_ENDPOINT = API_BASE + "/photo-save";

/* STATE */
let stream = null;
let videoTrack = null;
let cvReady = false;
let lastQuad = null;    // smoothed quad in full-resolution coords
let quadHistory = [];
const QUAD_HISTORY_LEN = 6;
let stableFrames = 0;
let autoCapture = true;
let lastCaptureAt = 0;
let images = [];

/* DOM */
const startBtn = document.getElementById("startBtn");
const toggleAuto = document.getElementById("toggleAuto");
const statusEl = document.getElementById("status");
const cameraBox = document.getElementById("camera-box");
const videoEl = document.getElementById("video");
const overlay = document.getElementById("overlay");
const overlayCtx = overlay.getContext("2d");
const infoOverlay = document.getElementById("infoOverlay");
const captureBtn = document.getElementById("captureBtn");
const saveBtn = document.getElementById("saveBtn");
const previewEl = document.getElementById("preview");

/* HELPERS */
function setStatus(t,c="yellow"){ statusEl.textContent=t; statusEl.className = c==="green"?"text-green-400 text-xs": c==="red"?"text-red-400 text-xs":"text-yellow-300 text-xs"; }
function setInfo(t=""){ infoOverlay.textContent = t; }

function orderQuad(pts){
  const sum = pts.map(p=>p.x+p.y);
  const diff = pts.map(p=>p.y-p.x);
  const tl = pts[sum.indexOf(Math.min(...sum))];
  const br = pts[sum.indexOf(Math.max(...sum))];
  const tr = pts[diff.indexOf(Math.min(...diff))];
  const bl = pts[diff.indexOf(Math.max(...diff))];
  return [tl,tr,br,bl];
}
function isValidQuad(q){ return q && q.length===4 && q.every(p=>Number.isFinite(p.x) && Number.isFinite(p.y)); }

/* smoothing history */
function pushQuad(q){
  if(!isValidQuad(q)) return null;
  quadHistory.push(q.map(p=>({x:p.x,y:p.y})));
  if(quadHistory.length > QUAD_HISTORY_LEN) quadHistory.shift();
  const n = quadHistory.length;
  const avg = [{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}];
  quadHistory.forEach(Q=>{
    for(let i=0;i<4;i++){ avg[i].x += Q[i].x; avg[i].y += Q[i].y; }
  });
  for(let i=0;i<4;i++){ avg[i].x /= n; avg[i].y /= n; }
  return avg;
}
function quadMotion(a,b){
  if(!isValidQuad(a) || !isValidQuad(b)) return Infinity;
  let s=0; for(let i=0;i<4;i++) s+= Math.hypot(a[i].x-b[i].x, a[i].y-b[i].y);
  return s/4;
}

/* luminance quick */
function meanLuminanceFromCanvas(c){
  try{ const ctx=c.getContext('2d'); const d = ctx.getImageData(0,0,c.width,c.height).data; let s=0,n=0; for(let i=0;i<d.length;i+=4){ s += 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; n++; } return s/n; }catch(e){ return 120; }
}

/* beep */
function beep(){ try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.connect(g); g.connect(ctx.destination); o.start(); g.gain.setValueAtTime(0.05,ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18); o.stop(ctx.currentTime + 0.19);}catch(e){} }

/* Wait for OpenCV */
(function waitForCV(){
  const timer = setInterval(()=>{
    if(window.cv && cv.Mat){
      cv.onRuntimeInitialized = ()=>{ cvReady = true; setStatus("OpenCV ready","green"); };
      clearInterval(timer);
    }
  },120);
})();

/* DRAW highlight (iPhone-like) */
function drawHighlight(pts){
  const w = overlay.width, h = overlay.height;
  overlayCtx.clearRect(0,0,w,h);

  // dark overlay
  overlayCtx.fillStyle = "rgba(0,0,0,0.55)";
  overlayCtx.fillRect(0,0,w,h);

  // cut-out polygon
  overlayCtx.save();
  overlayCtx.beginPath();
  overlayCtx.moveTo(pts[0].x, pts[0].y);
  overlayCtx.lineTo(pts[1].x, pts[1].y);
  overlayCtx.lineTo(pts[2].x, pts[2].y);
  overlayCtx.lineTo(pts[3].x, pts[3].y);
  overlayCtx.closePath();
  overlayCtx.globalCompositeOperation = "destination-out";
  overlayCtx.fill();
  overlayCtx.restore();

  // yellow fill
  overlayCtx.fillStyle = "rgba(255,220,0,0.34)";
  overlayCtx.beginPath();
  overlayCtx.moveTo(pts[0].x, pts[0].y);
  overlayCtx.lineTo(pts[1].x, pts[1].y);
  overlayCtx.lineTo(pts[2].x, pts[2].y);
  overlayCtx.lineTo(pts[3].x, pts[3].y);
  overlayCtx.closePath();
  overlayCtx.fill();

  // glow border
  overlayCtx.lineWidth = Math.max(3, Math.round(Math.min(w,h)*0.003));
  overlayCtx.strokeStyle = "rgba(255,200,0,0.28)";
  overlayCtx.stroke();
  overlayCtx.lineWidth = Math.max(2, Math.round(Math.min(w,h)*0.0016));
  overlayCtx.strokeStyle = "rgb(255,200,0)";
  overlayCtx.beginPath();
  overlayCtx.moveTo(pts[0].x, pts[0].y);
  overlayCtx.lineTo(pts[1].x, pts[1].y);
  overlayCtx.lineTo(pts[2].x, pts[2].y);
  overlayCtx.lineTo(pts[3].x, pts[3].y);
  overlayCtx.closePath();
  overlayCtx.stroke();
}

/* =========================
   SUPER DETECTION (wood-safe)
   - downsample for speed
   - normalize, remove wood texture, heavy closing
   - multi-criteria scoring
   ========================= */
function startDetectionLoop(){
  const procMax = 720; // tuned for mobile perf
  const detectCanvas = document.createElement('canvas');
  const dctx = detectCanvas.getContext('2d');

  // previous smoothed for motion calc
  let prevSmooth = null;

  async function step(){
    if(!stream) return requestAnimationFrame(step);
    if(!cvReady || !videoEl.videoWidth) return requestAnimationFrame(step);

    const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
    overlay.width = vw; overlay.height = vh;

    // compute downscale to speed
    const scale = Math.min(1, procMax / Math.max(vw, vh));
    const pw = Math.max(320, Math.floor(vw * scale));
    const ph = Math.max(320, Math.floor(vh * scale));
    detectCanvas.width = pw; detectCanvas.height = ph;

    dctx.drawImage(videoEl, 0, 0, pw, ph);

    // OpenCV processing on detectCanvas (smaller)
    let src = cv.imread(detectCanvas);
    let gray = new cv.Mat();
    let norm = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();
    let closed = new cv.Mat();
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();

    // 1. Grayscale + equalize to normalize brightness (helps wood)
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    try { cv.equalizeHist(gray, norm); } catch(e){ norm = gray.clone(); }

    // 2. Bilateral filter to remove texture but keep edges (wood desk handling)
    let smooth = new cv.Mat();
    cv.bilateralFilter(norm, smooth, 9, 75, 75);

    // 3. Slight Gaussian to remove noise
    cv.GaussianBlur(smooth, blur, new cv.Size(5,5), 1.2);

    // 4. Edge detection (Canny) with conservative thresholds
    cv.Canny(blur, edges, 20, 100);

    // 5. Morphology: dilate + close to join fragmented edges
    let kernel = cv.Mat.ones(7,7,cv.CV_8U);
    cv.dilate(edges, edges, kernel);
    cv.morphologyEx(edges, closed, cv.MORPH_CLOSE, kernel);

    // 6. find contours
    cv.findContours(closed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // prepare overlay
    overlayCtx.clearRect(0,0,overlay.width,overlay.height);

    // scoring params
    const MIN_AREA_RATIO = 0.045;  // allow smaller A4 if camera is far
    const A4_RATIO = 1.414;
    let bestScore = 0;
    let bestApprox = null;

    for(let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, peri * 0.018, true);

      if(approx.rows === 4){
        const area = Math.abs(cv.contourArea(approx));
        const areaRatio = area / (pw * ph);
        if(areaRatio < MIN_AREA_RATIO){ approx.delete(); cnt.delete(); continue; }

        // get pts and order them
        let pts = [];
        for(let j=0;j<4;j++) pts.push({ x: approx.intAt(j,0), y: approx.intAt(j,1) });
        pts = orderQuad(pts);

        // aspect ratio score
        const w = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
        const h = Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
        const ratio = Math.max(w,h) / Math.min(w,h);
        const ratioScore = Math.max(0, 1 - Math.abs(ratio - A4_RATIO) * 0.6);

        // solidity / rectangularity: compare contour area vs bounding box
        const bboxArea = (Math.max(pts[1].x,pts[2].x) - Math.min(pts[0].x,pts[3].x)) * (Math.max(pts[2].y,pts[3].y) - Math.min(pts[0].y,pts[1].y));
        const solidity = bboxArea > 0 ? area / bboxArea : 0;

        // final score (weighted)
        const score = areaRatio * 1.2 + ratioScore * 0.9 + solidity * 0.8;

        if(score > bestScore){
          bestScore = score;
          if(bestApprox) bestApprox.delete();
          bestApprox = approx;
        } else approx.delete();
      } else approx.delete();

      cnt.delete();
    }

    if(bestApprox){
      // map points back to original resolution
      const sx = vw / pw, sy = vh / ph;
      let pts = [];
      for(let k=0;k<4;k++) pts.push({ x: bestApprox.intAt(k,0)*sx, y: bestApprox.intAt(k,1)*sy });
      pts = orderQuad(pts);

      // smoothing with history
      const sm = pushQuad(pts);
      if(sm) lastQuad = sm;

      // draw highlight (smoothed)
      if(lastQuad) drawHighlight(lastQuad);

      setInfo("üìÑ Hujjat topildi ‚Äî barqaror joylang");

      // auto-capture checks: area + motion + brightness
      const areaRatioFull = Math.abs(cv.contourArea(bestApprox)) / (pw*ph);
      const brightness = meanLuminanceFromCanvas(detectCanvas); // 0-255
      const motion = prevSmooth ? quadMotion(lastQuad, prevSmooth) : 9999;
      const goodArea = areaRatioFull > 0.28;
      const lowMotion = motion < Math.max(vw,vh) * 0.007;
      const goodLight = brightness > 38;

      if(goodArea && lowMotion && goodLight && autoCapture){
        stableFrames++;
      } else stableFrames = Math.max(0, stableFrames - 1);

      if(stableFrames >= 6 && (Date.now() - lastCaptureAt) > 1200){
        stableFrames = 0;
        lastCaptureAt = Date.now();
        beep();
        triggerCapture(true);
      }

      prevSmooth = lastQuad;
    } else {
      // no candidate
      quadHistory = [];
      lastQuad = null;
      stableFrames = 0;
      setInfo("Hujjatni to‚Äòliq kadrga joylashtiring");
    }

    // cleanup
    src.delete(); gray.delete(); norm.delete(); blur.delete(); edges.delete(); closed.delete();
    contours.delete(); hierarchy.delete();
    if(bestApprox) bestApprox.delete();
    if(typeof kernel !== 'undefined') kernel.delete();
    if(typeof smooth !== 'undefined') smooth.delete();

    requestAnimationFrame(step);
  }

  step();
}

/* =========================
   CAMERA OPEN
   ========================= */
startBtn.addEventListener("click", async ()=>{
  try{
    setStatus("Kamera ochilyapti...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
      audio: false
    });
    videoTrack = stream.getVideoTracks()[0];
    videoEl.srcObject = stream;
    cameraBox.classList.remove("hidden");
    setStatus("Kamera tayyor", "green");
    startDetectionLoop();
  } catch(e){
    console.error(e);
    setStatus("Kamera ochilmadi: " + (e.message||e), "red");
  }
});

/* =========================
   CAPTURE & ENHANCE
   - perspective warp using lastQuad
   - CLAHE + bilateral + unsharp (safe fallback)
   ========================= */
async function triggerCapture(autoFlag=false){
  if(!videoEl.videoWidth) return;
  setStatus(autoFlag ? "Auto-capture..." : "Capturing...");

  // capture full frame
  const base = document.createElement('canvas');
  base.width = videoEl.videoWidth; base.height = videoEl.videoHeight;
  base.getContext('2d').drawImage(videoEl, 0, 0, base.width, base.height);

  let finalCanvas = base;

  if(cvReady && lastQuad && isValidQuad(lastQuad)){
    try{
      const pts = lastQuad;
      // compute dst dims
      const w1 = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
      const w2 = Math.hypot(pts[2].x-pts[3].x, pts[2].y-pts[3].y);
      const h1 = Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
      const h2 = Math.hypot(pts[2].x-pts[1].x, pts[2].y-pts[1].y);
      const dstW = Math.max(Math.floor(w1), Math.floor(w2));
      const dstH = Math.max(Math.floor(h1), Math.floor(h2));

      // warp using OpenCV
      const src = cv.imread(base);
      const dst = new cv.Mat();
      const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[
        pts[0].x, pts[0].y, pts[1].x, pts[1].y,
        pts[2].x, pts[2].y, pts[3].x, pts[3].y
      ]);
      const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, dstW,0, dstW,dstH, 0,dstH]);
      const M = cv.getPerspectiveTransform(srcTri, dstTri);
      cv.warpPerspective(src, dst, M, new cv.Size(dstW, dstH));

      // image enhance (CLAHE + bilateral + unsharp)
      try{
        let lab = new cv.Mat();
        cv.cvtColor(dst, lab, cv.COLOR_RGBA2Lab);
        let planes = new cv.MatVector(); cv.split(lab, planes);
        let L = planes.get(0);

        // CLAHE
        let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
        let Lc = new cv.Mat();
        clahe.apply(L, Lc);

        planes.set(0, Lc);
        cv.merge(planes, lab);
        let enhanced = new cv.Mat();
        cv.cvtColor(lab, enhanced, cv.COLOR_Lab2RGBA);

        // bilateral filter (noise removal)
        let smooth2 = new cv.Mat();
        cv.bilateralFilter(enhanced, smooth2, 9, 75, 75);

        // unsharp (sharpen)
        let sharpen = new cv.Mat();
        cv.addWeighted(enhanced, 1.5, smooth2, -0.5, 0, sharpen);

        finalCanvas = document.createElement('canvas');
        finalCanvas.width = sharpen.cols; finalCanvas.height = sharpen.rows;
        cv.imshow(finalCanvas, sharpen);

        // cleanup
        L.delete(); Lc.delete(); planes.delete(); lab.delete();
        clahe.delete(); enhanced.delete(); smooth2.delete(); sharpen.delete();
      } catch(e){
        // fallback: use warp result
        finalCanvas = document.createElement('canvas');
        finalCanvas.width = dst.cols; finalCanvas.height = dst.rows;
        cv.imshow(finalCanvas, dst);
      }

      src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
    } catch(e){
      console.error("Warp/enhance error:", e);
      finalCanvas = base;
    }
  }

  // convert to blob and preview/save
  const blob = await new Promise(res => finalCanvas.toBlob(res, "image/jpeg", 0.92));
  if(!blob){ setStatus("Capture failed", "red"); return; }

  images.push({ blob, url: URL.createObjectURL(blob) });
  renderPreview();
  saveBtn.classList.remove("hidden");
  setStatus("Saved", "green");
}

/* bind manual capture */
captureBtn.addEventListener("click", ()=> triggerCapture(false));

/* =========================
   PREVIEW & UPLOAD
   ========================= */
function renderPreview(){
  previewEl.innerHTML = "";
  images.forEach((it, idx)=>{
    const card = document.createElement('div');
    card.className = "bg-slate-800 p-2 rounded-xl border border-slate-700 flex items-center gap-3";
    const img = document.createElement('img'); img.src = it.url; img.className="w-24 h-24 object-cover rounded";
    card.appendChild(img);
    const dl = document.createElement('a'); dl.href=it.url; dl.download=`scan_${idx+1}.jpg`; dl.className="ml-auto px-2 py-1 bg-blue-600 rounded text-xs"; dl.textContent="‚¨áÔ∏è";
    card.appendChild(dl);
    const del = document.createElement('button'); del.className="ml-2 px-2 py-1 bg-red-600 rounded text-xs"; del.textContent="üóë";
    del.onclick = ()=> { images.splice(idx,1); renderPreview(); if(images.length===0) saveBtn.classList.add("hidden"); };
    card.appendChild(del);
    previewEl.appendChild(card);
  });
}

/* Upload all */
saveBtn.addEventListener("click", async ()=>{
  if(images.length===0) return;
  setStatus("Uploading...");
  const form = new FormData();
  images.forEach((it,i)=> form.append("photos", it.blob, `photo_${i}.jpg`));
  form.append("uid", localStorage.getItem("driver_uid") || "");
  try{
    const res = await fetch(SAVE_ENDPOINT, { method: "POST", body: form });
    const data = await res.json();
    if(data.ok){ images = []; renderPreview(); saveBtn.classList.add("hidden"); setStatus("All uploaded", "green"); }
    else setStatus(data.msg || "Upload failed", "red");
  } catch(e){ console.error(e); setStatus("Upload error", "red"); }
});

/* Toggle auto-capture */
toggleAuto.addEventListener("click", ()=> { autoCapture = !autoCapture; toggleAuto.textContent = `‚öôÔ∏è Auto: ${autoCapture ? "ON":"OFF"}`; });

/* Cleanup */
window.addEventListener("beforeunload", ()=> { if(stream) stream.getTracks().forEach(t=>t.stop()); });

</script>
</body>
</html>
