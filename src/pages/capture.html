<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fast Capture</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- OpenCV.js ‚Äì DEFER, async EMAS -->
  <script defer src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>

<body class="bg-slate-900 text-white min-h-screen">
  <div class="max-w-md mx-auto p-4">
    <h2 class="text-xl font-bold mb-4">Take Document Photo</h2>

    <!-- START + SAVE BUTTONS -->
    <div class="flex gap-3 mb-3">
      <button id="startBtn"
        class="flex-1 bg-slate-700 p-3 rounded-full active:scale-95 transition">
        üì∏ Open Camera
      </button>

      <button id="saveAllBtn"
        class="flex-1 bg-blue-600 p-3 rounded-full hidden active:scale-95 transition">
        üíæ Upload All Photos
      </button>
    </div>

    <p id="status" class="text-xs min-h-[20px] text-yellow-300"></p>

    <!-- CAMERA BOX -->
    <div id="cameraBox" class="hidden mt-4">
      <video id="video" autoplay playsinline
        class="w-full rounded-xl bg-black aspect-[3/4] object-cover"></video>

      <button id="captureBtn"
        class="w-full mt-3 bg-emerald-500 p-3 rounded-full active:scale-95 transition">
        üì∑ Capture Photo
      </button>
    </div>

    <!-- EDIT BOX -->
    <div id="editBox"
      class="hidden mt-4 border border-slate-700 rounded-xl overflow-hidden">
      <div class="relative">
        <canvas id="editCanvas" class="w-full block"></canvas>
        <div class="absolute bottom-0 inset-x-0 bg-black/60 text-xs p-2 text-center">
          Adjust borders by dragging the circles
        </div>
      </div>
      <div class="flex">
        <button id="retakeBtn"
          class="flex-1 bg-slate-700 py-2 text-center text-sm border-r border-slate-800">
          üîÅ Retake
        </button>
        <button id="saveCropBtn"
          class="flex-1 bg-emerald-600 py-2 text-center text-sm">
          ‚úÖ Save
        </button>
      </div>
    </div>

    <!-- PREVIEW -->
    <h3 class="mt-6 font-bold text-sm">Received Photos</h3>
    <div id="preview" class="space-y-2 mt-2"></div>
  </div>

<script>
window.addEventListener("load", () => {
/* ==========================
   GLOBAL
========================== */
let cvReady = false;
let stream = null;
let images = [];
let capturedCanvas = null;
let editScaleX = 1, editScaleY = 1;
let corners = [];
let draggingIndex = -1;

const statusEl   = document.getElementById("status");
const videoEl    = document.getElementById("video");
const cameraBox  = document.getElementById("cameraBox");
const editBox    = document.getElementById("editBox");
const editCanvas = document.getElementById("editCanvas");
const editCtx    = editCanvas.getContext("2d");
const previewEl  = document.getElementById("preview");
const saveAllBtn = document.getElementById("saveAllBtn");

function setStatus(t){ statusEl.textContent = t || ""; }

/* ==========================
   OpenCV READY
========================== */
if (window.cv) {
  cv['onRuntimeInitialized'] = () => {
    cvReady = true;
    setStatus("‚úÖ AI engine loaded.");
    console.log("OpenCV ready");
  };
} else {
  console.warn("cv not defined yet ‚Äì but script is deferred, so it should appear soon");
}

/* ==========================
   CAMERA START
========================== */
document.getElementById("startBtn").onclick = async () => {
  // Kamera OpenCV-ga bog‚Äòliq emas ‚Äì baribir ochilsin
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: {ideal:1920}, height:{ideal:1080} }
    });
  } catch (e) {
    console.error(e);
    setStatus("‚ùå Camera permission denied or blocked.");
    return;
  }

  videoEl.srcObject = stream;
  cameraBox.classList.remove("hidden");
  editBox.classList.add("hidden");

  if (!cvReady) {
    setStatus("üì∑ Camera ready. AI still loading, auto-detect may be delayed...");
  } else {
    setStatus("üì∑ Point the camera at the document.");
  }
};

/* ==========================
   CAPTURE FRAME
========================== */
document.getElementById("captureBtn").onclick = () => {
  if (!stream) return;

  const track    = stream.getVideoTracks()[0];
  const settings = track.getSettings();
  const w        = settings.width  || videoEl.videoWidth;
  const h        = settings.height || videoEl.videoHeight;

  capturedCanvas = document.createElement("canvas");
  capturedCanvas.width  = w;
  capturedCanvas.height = h;
  capturedCanvas.getContext("2d").drawImage(videoEl, 0, 0, w, h);

  openEditScreen();
};

/* ==========================
   OPEN EDIT SCREEN
========================== */
function openEditScreen() {
  if (!capturedCanvas) return;

  const imgW = capturedCanvas.width;
  const imgH = capturedCanvas.height;

  const displayW = 360;
  const ratio    = imgW / imgH;
  const displayH = Math.round(displayW / ratio);

  editCanvas.width  = displayW;
  editCanvas.height = displayH;

  editScaleX = displayW / imgW;
  editScaleY = displayH / imgH;

  editCtx.clearRect(0,0,displayW,displayH);
  editCtx.drawImage(capturedCanvas, 0, 0, displayW, displayH);

  if (cvReady) {
    corners = detectDocumentOnCanvas(capturedCanvas).map(p => ({
      x: p.x * editScaleX,
      y: p.y * editScaleY
    }));
  } else {
    // AI yuklanmagan bo‚Äòlsa ‚Äì butun sahifani o‚Äòramiz
    corners = [
      {x: 10,               y: 10},
      {x: displayW - 10,    y: 10},
      {x: displayW - 10,    y: displayH - 10},
      {x: 10,               y: displayH - 10}
    ];
  }

  drawEditOverlay();
  editBox.classList.remove("hidden");
  cameraBox.classList.add("hidden");
}

/* ==========================
   DOCUMENT DETECT (OpenCV)
========================== */
function detectDocumentOnCanvas(canvas) {
  const src       = cv.imread(canvas);
  const gray      = new cv.Mat();
  const blur      = new cv.Mat();
  const edges     = new cv.Mat();
  const contours  = new cv.MatVector();
  const hierarchy = new cv.Mat();

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

  const v     = cv.mean(gray)[0];
  const lower = Math.max(0, v*0.66);
  const upper = Math.min(255, v*1.33);
  cv.Canny(blur, edges, lower, upper);

  const kernel = cv.Mat.ones(3,3,cv.CV_8U);
  cv.dilate(edges, edges, kernel);
  cv.erode(edges, edges, kernel);

  cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

  const w = canvas.width;
  const h = canvas.height;
  let bestPts = null;
  let maxArea = 0;

  for (let i = 0; i < contours.size(); i++) {
    const cnt   = contours.get(i);
    const peri  = cv.arcLength(cnt, true);
    const approx= new cv.Mat();
    cv.approxPolyDP(cnt, approx, peri*0.02, true);

    if (approx.rows === 4) {
      const pts = [];
      for (let j=0; j<4; j++) {
        pts.push({ x: approx.intAt(j,0), y: approx.intAt(j,1) });
      }
      const area = cv.contourArea(cnt);
      if (area > maxArea && area > w*h*0.05) {
        maxArea = area;
        bestPts = pts;
      }
    }
  }

  src.delete(); gray.delete(); blur.delete();
  edges.delete(); contours.delete(); hierarchy.delete(); kernel.delete();

  if (!bestPts) {
    return [
      {x: 10,     y: 10},
      {x: w-10,   y: 10},
      {x: w-10,   y: h-10},
      {x: 10,     y: h-10}
    ];
  }

  bestPts.sort((a,b) => (a.y-b.y)||(a.x-b.x));
  const top    = bestPts.slice(0,2).sort((a,b)=>a.x-b.x);
  const bottom = bestPts.slice(2,4).sort((a,b)=>a.x-b.x);
  return [top[0], top[1], bottom[1], bottom[0]];
}

/* ==========================
   DRAW OVERLAY
========================== */
function drawEditOverlay() {
  const w = editCanvas.width;
  const h = editCanvas.height;

  editCtx.clearRect(0,0,w,h);
  editCtx.drawImage(capturedCanvas, 0, 0, w, h);

  if (!corners || corners.length !== 4) return;

  editCtx.lineWidth   = 2;
  editCtx.strokeStyle = "#22c55e";
  editCtx.shadowColor = "#22c55e";
  editCtx.shadowBlur  = 12;

  editCtx.beginPath();
  editCtx.moveTo(corners[0].x, corners[0].y);
  for (let i=1;i<4;i++) editCtx.lineTo(corners[i].x, corners[i].y);
  editCtx.closePath();
  editCtx.stroke();

  editCtx.shadowBlur = 0;
  for (const p of corners) {
    editCtx.beginPath();
    editCtx.arc(p.x, p.y, 10, 0, Math.PI*2);
    editCtx.fillStyle = "rgba(15,23,42,0.9)";
    editCtx.fill();
    editCtx.lineWidth = 2;
    editCtx.strokeStyle = "white";
    editCtx.stroke();
  }
}

/* ==========================
   DRAG HANDLES
========================== */
function getPos(e){
  const rect = editCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  return {x,y};
}

editCanvas.addEventListener("pointerdown", e => {
  if (!corners.length) return;
  const pos = getPos(e);
  for (let i=0;i<4;i++){
    const p = corners[i];
    const d = Math.hypot(p.x-pos.x, p.y-pos.y);
    if (d < 20) {
      draggingIndex = i;
      editCanvas.setPointerCapture(e.pointerId);
      break;
    }
  }
});

editCanvas.addEventListener("pointermove", e => {
  if (draggingIndex === -1) return;
  const pos = getPos(e);
  corners[draggingIndex].x = pos.x;
  corners[draggingIndex].y = pos.y;
  drawEditOverlay();
});

editCanvas.addEventListener("pointerup",   () => draggingIndex=-1);
editCanvas.addEventListener("pointercancel",() => draggingIndex=-1);

/* ==========================
   RETAKE / SAVE CROP
========================== */
document.getElementById("retakeBtn").onclick = () => {
  editBox.classList.add("hidden");
  cameraBox.classList.remove("hidden");
};

document.getElementById("saveCropBtn").onclick = async () => {
  if (!capturedCanvas || corners.length !== 4) return;

  const ptsImg = corners.map(p => ({
    x: p.x / editScaleX,
    y: p.y / editScaleY
  }));

  const src = cv.imread(capturedCanvas);
  const dst = new cv.Mat();

  const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[
    ptsImg[0].x, ptsImg[0].y,
    ptsImg[1].x, ptsImg[1].y,
    ptsImg[2].x, ptsImg[2].y,
    ptsImg[3].x, ptsImg[3].y
  ]);

  const w1 = Math.hypot(ptsImg[1].x-ptsImg[0].x, ptsImg[1].y-ptsImg[0].y);
  const w2 = Math.hypot(ptsImg[2].x-ptsImg[3].x, ptsImg[2].y-ptsImg[3].y);
  const h1 = Math.hypot(ptsImg[3].x-ptsImg[0].x, ptsImg[3].y-ptsImg[0].y);
  const h2 = Math.hypot(ptsImg[2].x-ptsImg[1].x, ptsImg[2].y-ptsImg[1].y);

  const dstW = Math.max(w1,w2);
  const dstH = Math.max(h1,h2);

  const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0,dstW,0,dstW,dstH,0,dstH]);

  const M = cv.getPerspectiveTransform(srcTri,dstTri);
  cv.warpPerspective(src,dst,M,new cv.Size(dstW,dstH));

  const outCanvas = document.createElement("canvas");
  outCanvas.width  = dst.cols;
  outCanvas.height = dst.rows;
  cv.imshow(outCanvas,dst);

  src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();

  const blob = await new Promise(r => outCanvas.toBlob(r,"image/jpeg",0.95));
  const url  = URL.createObjectURL(blob);
  images.push({blob,url});
  renderImages();

  editBox.classList.add("hidden");
  cameraBox.classList.remove("hidden");
  saveAllBtn.classList.remove("hidden");
};

/* ==========================
   PREVIEW
========================== */
function renderImages(){
  previewEl.innerHTML = "";
  images.forEach((img,i)=>{
    previewEl.innerHTML += `
      <div class="bg-slate-800 p-2 rounded-xl border border-slate-700 flex items-center gap-3">
        <img src="${img.url}" class="w-20 h-20 rounded-lg object-cover" />
        <span class="text-xs opacity-75">Page ${i+1}</span>
        <button class="ml-auto bg-red-600 text-xs rounded-full px-2 py-1"
          onclick="deleteImage(${i})">
          üóë Delete
        </button>
      </div>`;
  });
}


/* ==========================
   UPLOAD ALL (stub)
========================== */
document.getElementById("saveAllBtn").onclick = () => {
  alert("Here you can upload all photos. Count: " + images.length);
};

}); // window load
</script>
</body>
</html>
