<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fast Capture</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- OpenCV -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    body { background:#0f172a; color:white; }
  </style>
</head>

<body>
<div class="max-w-md mx-auto p-4">

  <h2 class="text-xl font-bold mb-4">Take Document Photo</h2>

  <!-- BUTTONS -->
  <div class="flex gap-3 mb-3">
    <button id="startBtn"
      class="flex-1 bg-slate-700 p-3 rounded-full active:scale-95 transition">
      ðŸ“¸ Open Camera
    </button>

    <button id="saveBtn"
      class="flex-1 bg-blue-600 p-3 rounded-full hidden active:scale-95 transition">
      ðŸ’¾ Upload All Photos
    </button>
  </div>

  <p id="status" class="text-xs min-h-[20px] text-yellow-300"></p>

  <!-- CAMERA BOX -->
  <div id="camera-box" class="hidden mt-4 relative">

    <!-- INFO OVERLAY -->
    <div id="infoOverlay"
      class="absolute left-1/2 -translate-x-1/2 bottom-3 bg-slate-900/70 px-3 py-1 rounded-full text-xs z-20">
    </div>

    <!-- VIDEO STREAM -->
    <video id="video" autoplay playsinline
      class="w-full rounded-xl bg-black aspect-[3/4] object-cover relative z-0"></video>

    <!-- AI BOUNDING BOX -->
    <canvas id="overlay"
      class="absolute inset-0 w-full h-full pointer-events-none z-10"></canvas>

    <!-- CAPTURE BUTTON -->
    <button id="captureBtn"
      class="w-full mt-3 bg-emerald-500 p-3 rounded-full active:scale-95 transition relative z-20">
      ðŸ“· Capture Photo
    </button>
  </div>

  <!-- PREVIEW -->
  <h3 class="mt-6 font-bold text-sm">Received Photos</h3>
  <div id="preview" class="space-y-2 mt-2"></div>

</div>

<script>

/* ======================================
      GLOBAL
====================================== */
let stream = null;
let images = [];
let lastQuad = null;
let prevQuad = null;
let stableCount = 0;
let autoCooldown = false;
let cvReady = false;

/* DOM */
const overlayCanvas = document.getElementById("overlay");
const overlayCtx = overlayCanvas.getContext("2d");
const infoOverlay = document.getElementById("infoOverlay");
const previewEl = document.getElementById("preview");
const saveBtn = document.getElementById("saveBtn");
const statusEl = document.getElementById("status");

function setInfo(t){ infoOverlay.textContent = t }
function setStatus(t){ statusEl.textContent = t }

/* ======================================
      WAIT FOR OpenCV
====================================== */
cvReady = false;
window.cv = window.cv || {};
cv['onRuntimeInitialized'] = () => {
  cvReady = true;
};

/* ======================================
      CAMERA START
====================================== */
document.getElementById("startBtn").onclick = async () => {

  if (!cvReady) {
    setStatus("â³ Loading AI modelâ€¦");
    await new Promise(r => setTimeout(r, 800));
  }

  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment", width: {ideal:1920}, height:{ideal:1080} }
  });

  document.getElementById("video").srcObject = stream;
  document.getElementById("camera-box").classList.remove("hidden");

  startDetectionLoop();
};

/* ======================================
      QUAD UTILITIES
====================================== */
function isSameQuad(a,b){
  if (!a || !b) return false;
  let d=0;
  for(let i=0;i<4;i++)
    d += Math.hypot(a[i].x-b[i].x, a[i].y-b[i].y);
  return d < 15;
}

function sortCorners(pts){
  pts.sort((a,b)=>(a.y-b.y)||(a.x-b.x));
  const top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
  const bottom = pts.slice(2,4).sort((a,b)=>a.x-b.x);
  return [ top[0], top[1], bottom[1], bottom[0] ];
}

function isSharp(gray){
  let lap = new cv.Mat();
  cv.Laplacian(gray, lap, cv.CV_64F);
  const d = lap.data64F;
  let m=0; for(let i=0;i<d.length;i++) m+=Math.abs(d[i]);
  lap.delete();
  return m/d.length > 8;
}

/* ======================================
      AUTO CAPTURE
====================================== */
function autoCapture(){
  if(autoCooldown) return;
  autoCooldown = true;

  overlayCanvas.style.boxShadow="0 0 35px 10px lime";

  setTimeout(()=>overlayCanvas.style.boxShadow="none",500);

  document.getElementById("captureBtn").click();

  setTimeout(()=>autoCooldown=false,1200);
}

/* ======================================
      SUPER DETECTOR (CamScanner Level)
====================================== */
function startDetectionLoop(){

  const video = document.getElementById("video");
  const temp = document.createElement("canvas");
  const ctx = temp.getContext("2d");

  function loop(){
    if(!stream || !video.videoWidth){
      requestAnimationFrame(loop);
      return;
    }

    const w = video.videoWidth;
    const h = video.videoHeight;

    temp.width=w; temp.height=h;
    overlayCanvas.width=w; overlayCanvas.height=h;

    ctx.drawImage(video,0,0,w,h);

    let src = cv.imread(temp);
    let gray=new cv.Mat(), blur=new cv.Mat(), edges=new cv.Mat();
    let contours=new cv.MatVector(), hierarchy=new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

    // ADAPTIVE CANNY
    let v=cv.mean(gray)[0];
    let low=Math.max(0, v*0.66);
    let high=Math.min(255, v*1.33);
    cv.Canny(blur, edges, low, high);

    // EDGE BOOST
    let kernel=cv.Mat.ones(3,3,cv.CV_8U);
    cv.dilate(edges,edges,kernel);
    cv.erode(edges,edges,kernel);

    cv.findContours(edges,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

    overlayCtx.clearRect(0,0,w,h);

    let best=null, bestPts=null, maxArea=0;

    for(let i=0;i<contours.size();i++){
      let cnt=contours.get(i);
      let peri=cv.arcLength(cnt,true);
      let approx=new cv.Mat();
      cv.approxPolyDP(cnt, approx, peri*0.02, true);

      if(approx.rows===4){
        let pts=[];
        for(let j=0;j<4;j++) pts.push({x:approx.intAt(j,0), y:approx.intAt(j,1)});

        let area=cv.contourArea(cnt);
        if(area>maxArea && area>w*h*0.05){
          maxArea=area;
          bestPts=pts;
        }
      }
    }

    if(bestPts){
      let pts=sortCorners(bestPts);
      lastQuad=pts;

      overlayCtx.beginPath();
      overlayCtx.moveTo(pts[0].x,pts[0].y);
      overlayCtx.lineTo(pts[1].x,pts[1].y);
      overlayCtx.lineTo(pts[2].x,pts[2].y);
      overlayCtx.lineTo(pts[3].x,pts[3].y);
      overlayCtx.closePath();
      overlayCtx.lineWidth=4;
      overlayCtx.strokeStyle="lime";
      overlayCtx.shadowColor="lime";
      overlayCtx.shadowBlur=15;
      overlayCtx.stroke();

      if(isSharp(gray)){
        setInfo("ðŸ“„ Document detected");
        if(isSameQuad(prevQuad, pts)) stableCount++;
        else stableCount=0;

        prevQuad=pts;

        if(stableCount>10) autoCapture();
      }
      else {
        setInfo("ðŸ” Hold still (blurry)");
        stableCount=0;
      }

    } else {
      lastQuad=null;
      prevQuad=null;
      stableCount=0;
      setInfo("Searching documentâ€¦");
    }

    src.delete(); gray.delete(); blur.delete();
    edges.delete(); contours.delete(); hierarchy.delete();

    requestAnimationFrame(loop);
  }

  loop();
}

/* ======================================
      CAPTURE + PERSPECTIVE CROP
====================================== */
document.getElementById("captureBtn").onclick = async () => {

  const video=document.getElementById("video");
  let track=stream.getVideoTracks()[0];
  let s=track.getSettings();

  const W=s.width||video.videoWidth;
  const H=s.height||video.videoHeight;

  const base=document.createElement("canvas");
  base.width=W; base.height=H;
  base.getContext("2d").drawImage(video,0,0,W,H);

  let finalCanvas=base;

  if(lastQuad){

    let pts=lastQuad;

    let src=cv.imread(base);
    let dst=new cv.Mat();

    let srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[
      pts[0].x,pts[0].y,
      pts[1].x,pts[1].y,
      pts[2].x,pts[2].y,
      pts[3].x,pts[3].y
    ]);

    let w1=Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
    let w2=Math.hypot(pts[2].x-pts[3].x, pts[2].y-pts[3].y);
    let h1=Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
    let h2=Math.hypot(pts[2].x-pts[1].x, pts[2].y-pts[1].y);

    let dstW=Math.max(w1,w2);
    let dstH=Math.max(h1,h2);

    let dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,dstW,0,dstW,dstH,0,dstH]);

    let M=cv.getPerspectiveTransform(srcTri,dstTri);
    cv.warpPerspective(src,dst,M,new cv.Size(dstW,dstH));

    finalCanvas=document.createElement("canvas");
    finalCanvas.width=dst.cols;
    finalCanvas.height=dst.rows;
    cv.imshow(finalCanvas,dst);

    src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
  }

  const blob = await new Promise(r=>finalCanvas.toBlob(r,"image/jpeg",0.95));
  const url = URL.createObjectURL(blob);

  images.push({blob,url});
  renderImages();
  saveBtn.classList.remove("hidden");
};

function renderImages(){
  previewEl.innerHTML="";
  images.forEach((img,i)=>{
    previewEl.innerHTML += `
      <div class="bg-slate-800 p-2 rounded-xl flex items-center gap-3">
        <img src="${img.url}" class="w-20 h-20 rounded-lg object-cover"/>
        <button class="ml-auto bg-red-600 text-xs rounded-full px-2 py-1"
          onclick="images.splice(${i},1); renderImages();">ðŸ—‘</button>
      </div>`;
  });
}

</script>
</body>
</html>
