<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Realtime Scanner</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script defer src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    body { background:#0f172a; color:white; }
    #overlayCanvas {
      position:absolute; 
      inset:0; 
      pointer-events:none; 
      z-index:10;
    }
  </style>
</head>

<body>
<div class="max-w-md mx-auto p-4">

  <h2 class="text-xl font-bold mb-4">Realtime Document Scanner</h2>

  <button id="startBtn" class="w-full bg-slate-700 p-3 rounded-full mb-4">
    ðŸ“¸ Open camera
  </button>

  <p id="status" class="text-yellow-300 text-xs"></p>

  <div id="cameraBox" class="relative hidden">
    <video id="video" autoplay playsinline 
      class="w-full rounded-xl bg-black aspect-[3/4] object-cover"></video>

    <canvas id="overlayCanvas"></canvas>
  </div>

</div>

<script>
let cvReady = false;
let stream = null;

cv['onRuntimeInitialized'] = () => {
  cvReady = true;
  document.getElementById("status").innerText = "AI Loaded!";
};

document.getElementById("startBtn").onclick = async () => {
  if (!cvReady) {
    document.getElementById("status").innerText = "Loading AI...";
    return;
  }

  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode:"environment", width:{ideal:1920}, height:{ideal:1080} }
  });

  const video = document.getElementById("video");
  video.srcObject = stream;

  document.getElementById("cameraBox").classList.remove("hidden");
  document.getElementById("status").innerText = "Point camera at document...";

  startDetectionLoop();
};

function startDetectionLoop() {

  const video = document.getElementById("video");
  const overlay = document.getElementById("overlayCanvas");
  const ctx = overlay.getContext("2d");

  function loop() {

    if (!stream || video.videoWidth === 0) {
      requestAnimationFrame(loop);
      return;
    }

    // Canvas size must match video frame
    overlay.width = video.videoWidth;
    overlay.height = video.videoHeight;

    // Create temp canvas to get frame pixels
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = video.videoWidth;
    tempCanvas.height = video.videoHeight;
    const tctx = tempCanvas.getContext("2d");
    tctx.drawImage(video, 0, 0);

    // Detect document
    let quad = detectDocument(tempCanvas);

    // Draw overlay
    ctx.clearRect(0,0,overlay.width,overlay.height);
    if (quad) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = "lime";
      ctx.shadowColor = "lime";
      ctx.shadowBlur = 15;

      ctx.beginPath();
      ctx.moveTo(quad[0].x, quad[0].y);
      ctx.lineTo(quad[1].x, quad[1].y);
      ctx.lineTo(quad[2].x, quad[2].y);
      ctx.lineTo(quad[3].x, quad[3].y);
      ctx.closePath();
      ctx.stroke();
    }

    requestAnimationFrame(loop);
  }

  loop();
}

function detectDocument(canvas) {

  const src = cv.imread(canvas);
  const gray = new cv.Mat();
  const blur = new cv.Mat();
  const edges = new cv.Mat();
  const contours = new cv.MatVector();
  const hierarchy = new cv.Mat();

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

  let v = cv.mean(gray)[0];
  cv.Canny(blur, edges, v*0.6, v*1.5);

  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let best = null;
  let maxArea = 0;
  const w = canvas.width;
  const h = canvas.height;

  for (let i = 0; i < contours.size(); i++) {
    let cnt = contours.get(i);
    let peri = cv.arcLength(cnt, true);
    let approx = new cv.Mat();

    cv.approxPolyDP(cnt, approx, peri * 0.02, true);

    if (approx.rows === 4) {
      let pts = [];
      for (let j=0; j<4; j++) {
        pts.push({ x: approx.intAt(j,0), y: approx.intAt(j,1) });
      }

      let area = cv.contourArea(cnt);

      if (area > maxArea && area > w*h*0.15) {  
        maxArea = area;
        best = pts;
      }
    }
  }

  src.delete(); gray.delete(); blur.delete();
  edges.delete(); contours.delete(); hierarchy.delete();

  if (!best) return null;

  best.sort((a,b)=> (a.y-b.y)||(a.x-b.x));
  const top = best.slice(0,2).sort((a,b)=>a.x-b.x);
  const bot = best.slice(2,4).sort((a,b)=>a.x-b.x);
  return [top[0], top[1], bot[1], bot[0]];
}
</script>

</body>
</html>
