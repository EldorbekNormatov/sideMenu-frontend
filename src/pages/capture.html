<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>iPhone-like Document Scanner — Auto Scan + Upload</title>

  <!-- OpenCV.js (async) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    :root{
      --bg:#071027;
      --panel:#061222;
      --accent:#ffd23f;
      --muted:#9aa7ba;
    }
    html,body{ height:100%; margin:0; background:linear-gradient(180deg,#031021,#071029); font-family: Inter, system-ui, -apple-system; color:#fff; -webkit-font-smoothing:antialiased;}
    .frame{ max-width:420px; margin:14px auto; border-radius:22px; overflow:hidden; background:linear-gradient(180deg,#071029,#061222); box-shadow:0 12px 40px rgba(2,6,23,0.6); }
    .topbar{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; }
    .pill{ color:var(--muted); padding:6px 10px; border-radius:999px; font-size:15px; cursor:pointer; user-select:none; }
    .video-shell{ position:relative; width:100%; aspect-ratio:9/16; background:#000; }
    video{ width:100%; height:100%; object-fit:cover; display:block; }
    canvas.overlay{ position:absolute; inset:0; pointer-events:none; }
    .controls{ position:absolute; left:0; right:0; bottom:14px; display:flex; align-items:center; justify-content:center; gap:18px; pointer-events:none; }
    .shutter{ pointer-events:auto; width:78px; height:78px; border-radius:50%; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,0.06); border:4px solid rgba(255,255,255,0.16); }
    .shutter .inner{ width:56px; height:56px; border-radius:50%; background:#fff; transform:scale(1); transition:transform .14s ease; }
    .thumb{ position:absolute; left:14px; bottom:20px; width:52px; height:38px; border-radius:8px; overflow:hidden; background:#061021; border:1px solid rgba(255,255,255,0.06); pointer-events:auto; }
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }
    .top-right-btn{ pointer-events:auto; padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.03); color:var(--muted); font-size:15px; }
    .status{ position:absolute; left:50%; top:12px; transform:translateX(-50%); color:var(--muted); font-size:13px; background:rgba(0,0,0,0.25); padding:6px 10px; border-radius:999px; pointer-events:none; }

    /* review/modal */
    .review-sheet{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(2,6,11,0.6), rgba(2,6,11,0.9)); z-index:60; padding:24px; }
    .review-card{ width:100%; max-width:420px; background: #051222; border-radius:16px; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,0.6); }
    .review-img{ width:100%; height:60vh; background:#000; display:flex; align-items:center; justify-content:center; }
    .review-img img{ max-width:100%; max-height:100%; display:block; }
    .review-actions{ display:flex; gap:12px; padding:14px; justify-content:space-between; align-items:center; background:linear-gradient(90deg,#021020,#031026); }
    .btn{ padding:10px 14px; border-radius:10px; border:0; font-weight:600; font-size:15px; cursor:pointer; }
    .btn.secondary{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.06); }
    .btn.primary{ background:var(--accent); color:#071022; }
    .bottom-actions{ padding:12px; display:flex; gap:8px; justify-content:space-between; align-items:center; }
    .upload-btn{ padding:10px 14px; background:#0ea5a4; color:#021; border-radius:10px; font-weight:700; cursor:pointer; border:0; }
    .small-muted{ color:var(--muted); font-size:13px; padding:0 12px 12px; }
    @media (max-width:420px){ .frame{ margin:8px; } .review-img{ height:55vh; } }
  </style>
</head>
<body>

  <div class="frame" id="frame">
    <div class="topbar">
      <div class="pill" id="cancelBtn">Cancel</div>
      <div class="status" id="status">Kamera tayyor</div>
      <div style="display:flex;gap:8px">
        <div class="pill top-right-btn" id="flashBtn">Flash</div>
        <div class="pill top-right-btn" id="autoBtn">Auto: ON</div>
      </div>
    </div>

    <div class="video-shell" id="videoShell">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay" class="overlay"></canvas>

      <div class="controls">
        <div class="thumb" id="thumbBtn" title="Last"><img id="thumbImg" src="" alt=""></div>
        <div class="shutter" id="shutter" title="Capture (manual)">
          <div class="inner" id="shutterInner"></div>
        </div>
        <div style="width:52px"></div>
      </div>
    </div>

    <div class="small-muted">Position the document in view.</div>

    <div style="padding:12px; color:var(--muted); font-size:13px; display:flex; justify-content:space-between; align-items:center;">
      <div>Captured: <span id="count">0</span></div>
      <button id="uploadAllBtn" class="upload-btn" style="display:none">Yuborish</button>
    </div>
  </div>

  <!-- Review modal -->
  <div class="review-sheet" id="review">
    <div class="review-card">
      <div class="review-img" id="reviewImgWrap"><img id="reviewImg" src=""></div>
      <div class="review-actions">
        <button class="btn secondary" id="retakeBtn">Retake</button>
        <div style="flex:1"></div>
        <button class="btn primary" id="keepBtn">Keep Scan</button>
      </div>
    </div>
  </div>

<script>
/* Full iPhone-like auto scanner + upload (single HTML)
   - Upload endpoint: https://panel.nvmailer.uz/photo-save
   - Field name for image(s): photos
*/

const UPLOAD_URL = "https://panel.nvmailer.uz/photo-save";
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const overlayCtx = overlay.getContext('2d');
const status = document.getElementById('status');
const shutter = document.getElementById('shutter');
const shutterInner = document.getElementById('shutterInner');
const thumbImg = document.getElementById('thumbImg');
const countEl = document.getElementById('count');
const review = document.getElementById('review');
const reviewImg = document.getElementById('reviewImg');
const retakeBtn = document.getElementById('retakeBtn');
const keepBtn = document.getElementById('keepBtn');
const cancelBtn = document.getElementById('cancelBtn');
const flashBtn = document.getElementById('flashBtn');
const autoBtn = document.getElementById('autoBtn');
const uploadAllBtn = document.getElementById('uploadAllBtn');

let stream = null;
let videoTrack = null;
let cvReady = false;
let lastQuad = null;
let quadHistory = [];
const QUAD_HISTORY_LEN = 6;
let stableFrames = 0;
let lastCaptureAt = 0;
let images = []; // {blob, url}
const procMax = 720;
let autoCapture = true;
let torchOn = false;

/* Wait for OpenCV runtime */
(function waitForCV(){
  const t = setInterval(()=>{
    if(window.cv && cv && cv.Mat){
      cv.onRuntimeInitialized = ()=> { cvReady = true; setStatus("OpenCV tayyor"); };
      clearInterval(t);
    }
  },120);
})();

function setStatus(t){ status.textContent = t; }

function orderQuad(pts){
  const sum = pts.map(p=>p.x+p.y), diff = pts.map(p=>p.y-p.x);
  return [
    pts[sum.indexOf(Math.min(...sum))],
    pts[diff.indexOf(Math.min(...diff))],
    pts[sum.indexOf(Math.max(...sum))],
    pts[diff.indexOf(Math.max(...diff))]
  ];
}
function isValidQuad(q){ return q && q.length===4 && q.every(p=>Number.isFinite(p.x) && Number.isFinite(p.y)); }
function pushQuad(q){
  if(!isValidQuad(q)) return null;
  quadHistory.push(q.map(p=>({x:p.x,y:p.y})));
  if(quadHistory.length>QUAD_HISTORY_LEN) quadHistory.shift();
  const n = quadHistory.length;
  const avg = [{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}];
  quadHistory.forEach(Q=>{ for(let i=0;i<4;i++){ avg[i].x += Q[i].x; avg[i].y += Q[i].y; }});
  for(let i=0;i<4;i++){ avg[i].x/=n; avg[i].y/=n; }
  return avg;
}
function quadMotion(a,b){ if(!isValidQuad(a)||!isValidQuad(b)) return Infinity; let s=0; for(let i=0;i<4;i++) s+=Math.hypot(a[i].x-b[i].x,a[i].y-b[i].y); return s/4; }

async function openCamera(){
  try{
    setStatus("Kamera ochilyapti...");
    const constraints = {
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 },
        frameRate: { ideal: 60, max: 60 }
      },
      audio: false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoTrack = stream.getVideoTracks()[0];

    // mirror off for environment
    const settings = videoTrack.getSettings?.();
    if(settings && settings.facingMode && settings.facingMode.includes('environment')){
      video.style.transform = 'none';
    }

    try{ await videoTrack.applyConstraints({ advanced:[{ width:1920, height:1080, frameRate:60 }] }); }catch(e){ /* ignore */ }

    video.srcObject = stream;
    await video.play();
    setStatus("Kamera tayyor");
    startDetectionLoop();
  } catch(e){
    console.error(e);
    setStatus("Kamera xatosi");
    alert("Kamera ochilmadi. HTTPS orqali oching va ruxsat bering.");
  }
}

/* Detection loop using OpenCV (best-effort) */
function startDetectionLoop(){
  const detectCanvas = document.createElement('canvas');
  const dctx = detectCanvas.getContext('2d');
  let prevSmooth = null;

  async function step(){
    if(!stream) return requestAnimationFrame(step);
    if(!cvReady || !video.videoWidth) return requestAnimationFrame(step);

    const vw = video.videoWidth, vh = video.videoHeight;
    overlay.width = vw; overlay.height = vh;

    const scale = Math.min(1, procMax / Math.max(vw,vh));
    const pw = Math.max(320, Math.floor(vw * scale));
    const ph = Math.max(320, Math.floor(vh * scale));
    detectCanvas.width = pw; detectCanvas.height = ph;
    dctx.drawImage(video, 0, 0, pw, ph);

    try{
      let src = cv.imread(detectCanvas);
      let gray = new cv.Mat();
      let norm = new cv.Mat();
      let smooth = new cv.Mat();
      let blur = new cv.Mat();
      let edges = new cv.Mat();
      let closed = new cv.Mat();
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      try{ cv.equalizeHist(gray, norm); } catch(e){ norm = gray.clone(); }
      cv.bilateralFilter(norm, smooth, 9, 75, 75);
      cv.GaussianBlur(smooth, blur, new cv.Size(5,5), 1.2);
      cv.Canny(blur, edges, 20, 100);
      let kernel = cv.Mat.ones(7,7,cv.CV_8U);
      cv.dilate(edges, edges, kernel);
      cv.morphologyEx(edges, closed, cv.MORPH_CLOSE, kernel);

      cv.findContours(closed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      overlayCtx.clearRect(0,0,overlay.width,overlay.height);

      const MIN_AREA_RATIO = 0.045;
      const A4_RATIO = 1.414;
      let bestScore = 0;
      let bestApprox = null;

      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, peri*0.018, true);

        if(approx.rows===4){
          const area = Math.abs(cv.contourArea(approx));
          const areaRatio = area / (pw*ph);
          if(areaRatio < MIN_AREA_RATIO){ approx.delete(); cnt.delete(); continue; }

          let pts = [];
          for(let j=0;j<4;j++) pts.push({ x: approx.intAt(j,0), y: approx.intAt(j,1) });
          pts = orderQuad(pts);

          const w = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
          const h = Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
          const ratio = Math.max(w,h) / Math.min(w,h);
          const ratioScore = Math.max(0, 1 - Math.abs(ratio - A4_RATIO)*0.6);

          const minX = Math.min(...pts.map(p=>p.x));
          const maxX = Math.max(...pts.map(p=>p.x));
          const minY = Math.min(...pts.map(p=>p.y));
          const maxY = Math.max(...pts.map(p=>p.y));
          const bboxArea = (maxX-minX)*(maxY-minY);
          const solidity = bboxArea>0 ? area / bboxArea : 0;

          const score = areaRatio*1.2 + ratioScore*0.9 + solidity*0.8;
          if(score > bestScore){
            bestScore = score;
            if(bestApprox) bestApprox.delete();
            bestApprox = approx;
          } else approx.delete();
        } else approx.delete();
        cnt.delete();
      }

      if(bestApprox){
        const sx = vw / pw, sy = vh / ph;
        let pts = [];
        for(let k=0;k<4;k++) pts.push({ x: bestApprox.intAt(k,0)*sx, y: bestApprox.intAt(k,1)*sy });
        pts = orderQuad(pts);
        const sm = pushQuad(pts);
        if(sm) lastQuad = sm;
        if(lastQuad) drawHighlight(lastQuad);
        setStatus("Hujjat topildi — joyini barqarorlang");

        // auto-capture criteria
        const areaRatioFull = Math.abs(cv.contourArea(bestApprox)) / (pw*ph);
        const brightness = meanLuminanceFromCanvas(detectCanvas);
        const motion = prevSmooth ? quadMotion(lastQuad, prevSmooth) : 9999;

        const goodArea = areaRatioFull > 0.28;
        const lowMotion = motion < Math.max(vw,vh) * 0.007;
        const goodLight = brightness > 36;

        if(goodArea && lowMotion && goodLight && autoCapture) stableFrames++;
        else stableFrames = Math.max(0, stableFrames-1);

        if(stableFrames >= 5 && (Date.now()-lastCaptureAt) > 900){
          stableFrames = 0;
          lastCaptureAt = Date.now();
          playShutterAnim();
          await capture(true);
        }
        prevSmooth = lastQuad;
      } else {
        quadHistory = [];
        lastQuad = null;
        stableFrames = 0;
        setStatus("Hujjatni to'liq kadrga joylashtiring");
      }

      // cleanup mats
      src.delete(); gray.delete(); norm.delete(); blur.delete(); edges.delete(); closed.delete();
      contours.delete(); hierarchy.delete();
      if(bestApprox) bestApprox.delete();
      if(kernel) kernel.delete();
      if(smooth) smooth.delete();

    }catch(err){
      console.warn("detect err", err);
    }

    requestAnimationFrame(step);
  }

  step();
}

/* draw highlight */
function drawHighlight(pts){
  const w = overlay.width, h = overlay.height;
  overlayCtx.clearRect(0,0,w,h);

  overlayCtx.fillStyle = "rgba(0,0,0,0.55)";
  overlayCtx.fillRect(0,0,w,h);

  overlayCtx.save();
  overlayCtx.beginPath();
  overlayCtx.moveTo(pts[0].x, pts[0].y);
  overlayCtx.lineTo(pts[1].x, pts[1].y);
  overlayCtx.lineTo(pts[2].x, pts[2].y);
  overlayCtx.lineTo(pts[3].x, pts[3].y);
  overlayCtx.closePath();
  overlayCtx.globalCompositeOperation = "destination-out";
  overlayCtx.fill();
  overlayCtx.restore();

  overlayCtx.fillStyle = "rgba(255,220,0,0.22)";
  overlayCtx.beginPath();
  overlayCtx.moveTo(pts[0].x, pts[0].y);
  overlayCtx.lineTo(pts[1].x, pts[1].y);
  overlayCtx.lineTo(pts[2].x, pts[2].y);
  overlayCtx.lineTo(pts[3].x, pts[3].y);
  overlayCtx.closePath();
  overlayCtx.fill();

  overlayCtx.lineWidth = Math.max(3, Math.round(Math.min(w,h)*0.003));
  overlayCtx.strokeStyle = "rgba(255,200,0,0.3)";
  overlayCtx.stroke();

  overlayCtx.lineWidth = Math.max(2, Math.round(Math.min(w,h)*0.0016));
  overlayCtx.strokeStyle = "rgb(255,200,0)";
  overlayCtx.beginPath();
  overlayCtx.moveTo(pts[0].x, pts[0].y);
  overlayCtx.lineTo(pts[1].x, pts[1].y);
  overlayCtx.lineTo(pts[2].x, pts[2].y);
  overlayCtx.lineTo(pts[3].x, pts[3].y);
  overlayCtx.closePath();
  overlayCtx.stroke();

  overlayCtx.fillStyle = "rgba(255,255,255,0.95)";
  for(let p of pts){
    overlayCtx.beginPath(); overlayCtx.arc(p.x, p.y, 4, 0, Math.PI*2); overlayCtx.fill();
  }
}

/* mean luminance */
function meanLuminanceFromCanvas(c){
  try{
    const ctx = c.getContext('2d');
    const d = ctx.getImageData(0,0,c.width,c.height).data;
    let s=0,n=0;
    for(let i=0;i<d.length;i+=4){ s += 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; n++; }
    return s/n;
  }catch(e){ return 120; }
}

/* capture (warp using lastQuad if available) */
async function capture(auto=false){
  if(!video.videoWidth) return;
  setStatus(auto ? "Auto-capturing..." : "Capturing...");
  const base = document.createElement('canvas');
  base.width = video.videoWidth; base.height = video.videoHeight;
  base.getContext('2d').drawImage(video, 0, 0, base.width, base.height);

  let finalCanvas = base;

  if(cvReady && lastQuad && isValidQuad(lastQuad)){
    try{
      const pts = lastQuad;
      const w1 = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
      const w2 = Math.hypot(pts[2].x-pts[3].x, pts[2].y-pts[3].y);
      const h1 = Math.hypot(pts[3].x-pts[0].x, pts[3].y-pts[0].y);
      const h2 = Math.hypot(pts[2].x-pts[1].x, pts[2].y-pts[1].y);
      const dstW = Math.max(Math.floor(w1), Math.floor(w2));
      const dstH = Math.max(Math.floor(h1), Math.floor(h2));

      const src = cv.imread(base);
      const dst = new cv.Mat();
      const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[
        pts[0].x, pts[0].y, pts[1].x, pts[1].y,
        pts[2].x, pts[2].y, pts[3].x, pts[3].y
      ]);
      const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, dstW,0, dstW,dstH, 0,dstH]);
      const M = cv.getPerspectiveTransform(srcTri, dstTri);
      cv.warpPerspective(src, dst, M, new cv.Size(dstW, dstH));

      // light enhancement: CLAHE
      try{
        let lab = new cv.Mat();
        cv.cvtColor(dst, lab, cv.COLOR_RGBA2Lab);
        let planes = new cv.MatVector(); cv.split(lab, planes);
        let L = planes.get(0);
        let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
        let Lc = new cv.Mat(); clahe.apply(L, Lc);
        planes.set(0, Lc);
        cv.merge(planes, lab);
        let enhanced = new cv.Mat();
        cv.cvtColor(lab, enhanced, cv.COLOR_Lab2RGBA);
        finalCanvas = document.createElement('canvas'); finalCanvas.width = enhanced.cols; finalCanvas.height = enhanced.rows;
        cv.imshow(finalCanvas, enhanced);

        L.delete(); Lc.delete(); planes.delete(); lab.delete(); enhanced.delete(); clahe.delete();
      } catch(e){
        finalCanvas = document.createElement('canvas'); finalCanvas.width = dst.cols; finalCanvas.height = dst.rows;
        cv.imshow(finalCanvas, dst);
      }

      src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
    } catch(e){
      console.error("warp error", e);
      finalCanvas = base;
    }
  }

  const blob = await new Promise(res => finalCanvas.toBlob(res, "image/jpeg", 0.94));
  if(!blob){ setStatus("Capture failed"); return; }

  const url = URL.createObjectURL(blob);

  // show review screen
  reviewImg.src = url;
  review.style.display = 'flex';
  reviewImg.dataset.tmpUrl = url;
  reviewImg.dataset.tmpBlob = null;

  // keep blob for upload after Keep
  // but to avoid holding blob twice, convert via fetch
  finalCanvas.toBlob(b => { reviewImg.dataset.tmpBlob = b ? b : ''; }, "image/jpeg", 0.94);
}

/* shutter anim & manual capture */
shutter.addEventListener('click', ()=> { playShutterAnim(); capture(false); });
function playShutterAnim(){ shutterInner.style.transform = 'scale(.78)'; setTimeout(()=> shutterInner.style.transform='scale(1)',140); }

/* review actions */
retakeBtn.addEventListener('click', ()=> {
  if(reviewImg.dataset.tmpUrl) URL.revokeObjectURL(reviewImg.dataset.tmpUrl);
  reviewImg.src = ''; reviewImg.dataset.tmpUrl=''; reviewImg.dataset.tmpBlob='';
  review.style.display = 'none';
});

keepBtn.addEventListener('click', ()=> {
  const url = reviewImg.dataset.tmpUrl;
  const blob = reviewImg.dataset.tmpBlob;
  if(url && blob){
    images.push({ url, blob });
    thumbImg.src = url;
    countEl.textContent = images.length;
    uploadAllBtn.style.display = images.length>0 ? 'inline-block' : 'none';
  }
  review.style.display = 'none';
  // cleanup tmp dataset
  reviewImg.dataset.tmpUrl=''; reviewImg.dataset.tmpBlob='';
});

/* cancel stops stream */
cancelBtn.addEventListener('click', ()=> {
  if(stream) stream.getTracks().forEach(t=>t.stop());
  setStatus("Kamera to'xtatildi");
});

/* flash/torch toggle (if supported) */
flashBtn.addEventListener('click', async ()=>{
  if(!videoTrack) return alert("Torch qo'llab-quvvatlanmaydi");
  const caps = videoTrack.getCapabilities?.();
  if(!caps?.torch) return alert("Torch qo'llab-quvvatlanmaydi");
  try{
    torchOn = !torchOn;
    await videoTrack.applyConstraints({ advanced:[{ torch: torchOn }] });
    flashBtn.textContent = torchOn ? "Flash: ON" : "Flash";
  }catch(e){
    console.warn(e); alert("Torchni boshqarib bo'lmadi");
  }
});

/* Auto toggle */
autoBtn.addEventListener('click', ()=> {
  autoCapture = !autoCapture;
  autoBtn.textContent = `Auto: ${autoCapture ? 'ON' : 'OFF'}`;
});

/* Upload function — sends all kept images to server as form-data with field name 'photos' */
uploadAllBtn.addEventListener('click', async ()=>{
  if(images.length===0) return alert("Hech nima yo'q");
  uploadAllBtn.disabled = true; uploadAllBtn.textContent = 'Yuborilmoqda...';
  try{
    const form = new FormData();
    images.forEach((it, i)=>{
      // if blob is stored as string (rare), try fetch
      if(it.blob instanceof Blob){
        form.append('photos', it.blob, `scan_${i+1}.jpg`);
      } else {
        // fallback: fetch blob from object URL
        form.append('photos', it.blob || '', `scan_${i+1}.jpg`);
      }
    });
    // optional: add extra fields
    form.append('source','web-scanner-clone');

    const res = await fetch(UPLOAD_URL, { method:'POST', body: form });
    const data = await res.json().catch(()=> null);
    if(res.ok){
      alert("Yuborildi");
      // cleanup local stored images
      images.forEach(it => { try{ URL.revokeObjectURL(it.url); }catch(e){} });
      images = [];
      thumbImg.src = '';
      countEl.textContent = 0;
      uploadAllBtn.style.display = 'none';
    } else {
      console.error("upload error", res.status, data);
      alert("Yuborishda xato: " + (data?.msg || res.statusText || res.status));
    }
  }catch(e){
    console.error(e);
    alert("Yuborishda xato");
  } finally {
    uploadAllBtn.disabled = false; uploadAllBtn.textContent = 'Yuborish';
  }
});

/* Utility: convert dataURL to blob (not used here) */
function dataURLToBlob(dataurl) {
  const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
  while(n--) u8arr[n] = bstr.charCodeAt(n);
  return new Blob([u8arr], {type:mime});
}

/* autostart */
document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=> openCamera().catch(()=>{}), 250); });
</script>

</body>
</html>
