<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Realtime Scanner</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- OpenCV MUST NOT be async ‚Äî we load it first -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    body { background:#0f172a; color:white; }
    #overlayCanvas {
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:15;
    }
  </style>
</head>

<body>
<div class="max-w-md mx-auto p-4">

  <h2 class="text-xl font-bold mb-4">Realtime Document Scanner</h2>

  <button id="startBtn"
    class="w-full bg-slate-700 p-3 rounded-full mb-4">
    üì∏ Open Camera
  </button>

  <p id="status" class="text-yellow-300 text-xs"></p>

  <div id="cameraBox" class="relative hidden">
    <video id="video" autoplay playsinline
      class="w-full rounded-xl bg-black aspect-[3/4] object-cover"></video>

    <canvas id="overlayCanvas"></canvas>
  </div>

</div>

<script>
/* ===================================
      WAIT FOR OpenCV TO LOAD
=================================== */
let cvReady = false;
window.Module = {
  onRuntimeInitialized() {
    cvReady = true;
    document.getElementById("status").innerText = "AI engine loaded ‚úî";
  }
};

/* Helper: wait until OpenCV is ready */
function waitForCV(callback) {
  if (cvReady && window.cv) callback();
  else setTimeout(() => waitForCV(callback), 50);
}

/* ===================================
       START CAMERA
=================================== */
document.getElementById("startBtn").onclick = () => {
  waitForCV(() => startCamera());
};

async function startCamera() {
  document.getElementById("status").innerText = "Opening camera...";

  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width:{ideal:1920}, height:{ideal:1080} }
    });

    const video = document.getElementById("video");
    video.srcObject = stream;

    document.getElementById("cameraBox").classList.remove("hidden");
    document.getElementById("status").innerText = "Point camera at document...";

    startDetectionLoop();
  } catch(e) {
    document.getElementById("status").innerText = "‚ùå Camera blocked or unavailable.";
  }
}

/* ===================================
    REALTIME DETECTION LOOP
=================================== */
function startDetectionLoop() {
  const video = document.getElementById("video");
  const overlay = document.getElementById("overlayCanvas");
  const ctx = overlay.getContext("2d");

  function loop() {

    if (video.videoWidth === 0) {
      requestAnimationFrame(loop);
      return;
    }

    overlay.width  = video.videoWidth;
    overlay.height = video.videoHeight;

    /* Capture current frame */
    const temp = document.createElement("canvas");
    temp.width = video.videoWidth;
    temp.height = video.videoHeight;
    const tctx = temp.getContext("2d");
    tctx.drawImage(video, 0, 0);

    /* Detect document */
    const quad = detectDocument(temp);

    /* Draw bounding box */
    ctx.clearRect(0,0,overlay.width,overlay.height);

    if (quad) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = "lime";
      ctx.shadowColor = "lime";
      ctx.shadowBlur = 20;

      ctx.beginPath();
      ctx.moveTo(quad[0].x, quad[0].y);
      ctx.lineTo(quad[1].x, quad[1].y);
      ctx.lineTo(quad[2].x, quad[2].y);
      ctx.lineTo(quad[3].x, quad[3].y);
      ctx.closePath();
      ctx.stroke();
    }

    requestAnimationFrame(loop);
  }

  loop();
}

/* ===================================
         DOCUMENT DETECTOR
=================================== */
function detectDocument(canvas) {
  const src = cv.imread(canvas);

  const gray      = new cv.Mat();
  const blur      = new cv.Mat();
  const edges     = new cv.Mat();
  const contours  = new cv.MatVector();
  const hierarchy = new cv.Mat();

  /* Preprocess */
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

  const avg = cv.mean(gray)[0];
  cv.Canny(blur, edges, avg * 0.5, avg * 1.5);

  /* Find external edges only */
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const W = canvas.width;
  const H = canvas.height;
  let best = null;
  let maxArea = 0;

  for (let i = 0; i < contours.size(); i++) {
    const cnt = contours.get(i);
    const peri = cv.arcLength(cnt, true);
    const approx = new cv.Mat();

    cv.approxPolyDP(cnt, approx, peri * 0.02, true);

    /* Only polygons with 4 sides */
    if (approx.rows === 4) {

      const pts = [];
      for (let j = 0; j < 4; j++)
        pts.push({ x: approx.intAt(j,0), y: approx.intAt(j,1) });

      const area = cv.contourArea(cnt);

      /* Must be big enough (15% of frame) */
      if (area > maxArea && area > W * H * 0.15) {
        maxArea = area;
        best = pts;
      }
    }

    approx.delete();
    cnt.delete();
  }

  /* Free memory */
  src.delete(); gray.delete(); blur.delete();
  edges.delete(); contours.delete(); hierarchy.delete();

  if (!best) return null;

  /* Sort: TL, TR, BR, BL */
  best.sort((a,b) => (a.y - b.y) || (a.x - b.x));
  const top = best.slice(0,2).sort((a,b)=>a.x-b.x);
  const bot = best.slice(2,4).sort((a,b)=>a.x-b.x);

  return [top[0], top[1], bot[1], bot[0]];
}
</script>

</body>
</html>
